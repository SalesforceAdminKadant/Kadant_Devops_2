<apex:page controller="MachineSectionMapController" showHeader="true" sidebar="false" tabStyle="Account" action="{!Init}">

    <apex:includeLightning />

    <div id="lightning" />

    <apex:includeScript value="{!URLFOR($Resource.jQueryUI, '/jquery-ui-1.12.1.custom/external/jquery/jquery.js')}" />
    <apex:includeScript value="{!URLFOR($Resource.jQueryUI, '/jquery-ui-1.12.1.custom/jquery-ui.js')}" />
    <apex:includeScript value="/soap/ajax/44.0/connection.js" />
    <apex:includeScript value="/canvas/sdk/js/publisher.js" />

    <apex:outputPanel layout="none" rendered="{!GoJS_Debug = true}">
        <script type="text/javascript" src="/resource/0123456789/{!GoJS_Resource}/GoJS/go-debug.js"></script>
    </apex:outputPanel>
    <apex:outputPanel layout="none" rendered="{!GoJS_Debug = false}">
        <script type="text/javascript" src="/resource/0123456789/{!GoJS_Resource}/GoJS/go.js"></script>
    </apex:outputPanel>

    <apex:stylesheet value="{!URLFOR($Resource.jQueryUI, '/jquery-ui-1.12.1.custom/jquery-ui.css')}" />
    <apex:stylesheet value="{!URLFOR($Resource.FontAwesome, '/font-awesome-4.7.0/css/font-awesome.min.css')}" />

    <style type="text/css">
        #Creping {
            transform: rotate(-20deg);
        }

        img.helpOrb {
            position: absolute;
            right: -16px;
        }

        .inline {
            display: inline;
        }

        .floatRight {
            float: right;
        }

        .height360 {
            height: 360px;
        }

        .initiallyHidden {
            display: none;
        }

        .fullWidth {
            width: 100%;
        }

        .shiftRight {
            margin-right: -5px;
        }

        .valignTop {
            vertical-align: text-top;
        }

        #closeDialog, #saveAsDialog {
            display: none;
        }

        .ui-menu {
            width: 150px;
        }

        #menu {
            background-color: transparent !important;
            margin-top: 10px !important;
            height: 30px;
            width: 100%;
            border: 0px;
            display: none;
        }

            #menu > li {
                float: left;
            }

        .ui-menu-icon {
            background-color: transparent;
        }

        .ui-controlgroup-vertical {
            width: 150px;
        }       

        span.required::before {
            content: " ";
            background-color: #C00;
            white-space: pre;
            height: 100%;
        }

        .requiredInput {
            position: relative;
            height: 100%;
        }

        .requiredBlock {
            background-color: #C00;
            position: absolute;
            left: -4px;
            width: 3px;
            top: 1px;
            bottom: 1px;
        }

        .topRow {
            display: inline-block;
            vertical-align: middle;
        }

        .topSpacer {
            margin: 10px;
        }

        .toolbar > label {
            margin-left: 1px !important;
            background-color: transparent !important;
            color: black !important;
        }

        .toolbar > .ui-state-active {
            border-color: #c5c5c5 !important;
        }

        .ui-accordion-content > div {
            width: 100% !important;
        }

        .ui-accordion-content {
            padding-left: 5px !important;
            padding-right: 5px !important;
        }

        .topBox {
            margin-top: 2px;
            border-color: rgb(197, 197, 197) !important;
            border-radius: 3px;
            border-width: 1px;
            border-style: solid;
        }

        .mainBlock {
            width: 100%;
            white-space: nowrap;
        }

        #palette {
            display: none;
            width: 15%;
            display: inline-block;
            vertical-align: top;
            overflow-x: auto;
        }

        #metadataTable {
            width: 100% !important;
        }

        #metadataHeader {
            font-family: Arial,Helvetica,sans-serif;
        }

        .colLabelTop {
            width: 25%;
            text-align: right;
            vertical-align: top !important;
            font-family: Arial,Helvetica,sans-serif;
            padding-right: 12px;
        }

        .colLabel {
            width: 25%;
            text-align: right;
            vertical-align: middle !important;
            font-family: Arial,Helvetica,sans-serif;
            padding-right: 12px;
        }

        .colValue {
            width: 70%;
        }

            .colValue > div {
                width: 100%;
            }
                .colValue > div > input,
                .colValue > div > textarea {
                    width: 90%;
                    -webkit-box-sizing: border-box; /* Safari/Chrome, other WebKit */
                    -moz-box-sizing: border-box; /* Firefox, other Gecko */
                    box-sizing: border-box; /* Opera/IE 8+ */
                }

                    .colValue > div > input[type='checkbox'] {
                        display: inline-block;
                        width: auto;
                    }

        .images {
            display: none;
        }

        #diagramDiv {
            width: 50%;
            display: inline-block;
            vertical-align: top;
            border: solid 1px black;
            height: 584px;
        }

        #metadataGroup {
            width: 35%;
            display: inline-block;
            vertical-align: top;
            overflow-y: scroll;
        }

        #attachment-inner {
            border: 1px dashed gray;
            width: 90%;
            height: 50px;
            text-align: center;
        }

        #select-attachments {
            padding-top: 15px;
        }

        #attachment-help {
            white-space: normal;
            word-wrap: normal;
            width: 90%;
        }

        #attachment-help-div {
            width: 90%;
            padding: 10px;
        }

        #attachment-drag-box {
            text-align: -webkit-center;
        }

        #attachment-inner.drag-active {
            background-color: blue;
        }

        #attachment-inner {
            background-color: white;
        }

        #attachmentsDiv {
            text-align: -webkit-center;
        }

        #upload-div {
            text-align: -webkit-center;
        }

        #attachmentsTable {
            border: 1px solid lightgray;
            border-bottom: none;
            width: 90%;
        }

        #upload-table {
            border: 1px solid lightgray;
            border-bottom: none;
            width: 90%;
        }

        #attachmentsTable th {
            text-align: center;
            border-bottom: 1px solid lightgray;
            border-right: 1px solid lightgray;
        }

        #attachmentsTable td {
            border-bottom: 1px solid lightgray;
            border-right: 1px solid lightgray;
        }

            #attachmentsTable td.wrapped {
                word-wrap: break-word;
            }

            #attachmentsTable td.centered {
                text-align: center;
            }

            #attachmentsTable td:last-child {
                border-right: none;
            }

        #attachmentsTable th:last-child {
            border-right: none;
        }

        #attachmentsTable a {
            text-decoration: underline;
            color: -webkit-link;
            cursor: pointer;
        }

        #uploadDrop {
            width: 250px;
            height: 50px;
            padding: 10px;
            border: 1px solid #aaaaaa;
            text-align: center;
            vertical-align: middle;
            display: table-cell;
        }

        #toast {
            visibility: hidden;
            min-width: 150px;
            margin: -100px 0 0 -150px;
            background-color: #333;
            color: #fff;
            text-align: center;
            border-radius: 5px;
            padding: 16px;
            position: fixed;
            z-index: 1;
            left: 50%;
            top: 50%;
            height: 26px;
            vertical-align: middle;
        }

        #toast.show {
            visibility: visible;
            -webkit-animation: fadein 0.5s, fadeout 0.5s 2.0s;
            animation: fadein 0.5s, fadeout 0.5s 2.0s;
            background-color: #333;
            z-index: 1000;
        }

        #saveOverlay {
            position: fixed; /* Sit on top of thepage content */
            display: none; /* Hidden by default */
            width: 100%; /*Full width (cover the whole page) */
            height: 100%; /* Full height (cover the whole page) */
            top: 0;
            left: 0;
            right: 0;
            bottom: 0;
            background-color: rgba(0,0,0,0.5); /* Black background with opacity */
            z-index: 2; /* Specify a stack order in case you're using a different order for otherelements */
        }

        .shower-modal {
            display: none; /* Hidden by default */
            position: fixed; /* Stay in place */
            z-index: 2;
            top: 0;
            left: 0;
            right: 0;
            bottom: 0;
            width: 100%; /* Full width */
            height: 100%; /* Full height */
            overflow: auto; /* Enable scroll if needed */
            background-color: rgba(0,0,0,0.5); /* Black background with opacity */
        }

        .shower-modal:target {
            opacity:1;
            pointer-events: auto;
        }
  
        .shower-content {
            background-color: #fefefe;
            margin: 10% auto;
            padding: 20px;
            border: 1px solid #888;
            width: 600px; /* Could be more or less, depending on screen size */
            height: 700px;
            z-index: 3;
        }

        .shower-close {
            color: white;
            font-size: 28px;
            font-weight: bold;
        }
        .shower-close:hover,
        .shower-close:focus {
            color: black;
            text-decoration: none;
            cursor: pointer;
        }
        
        #overLayText {
            position: absolute;
            top: 50%;
            left: 50%;
            font-size: 20px;
            color: white;
            transform: translate(-50%,-50%);
            -ms-transform: translate(-50%,-50%);
        }

        .red-background {
            background: red;
        }

        .red-border {
            border: 1px solid red !important;
        }

        @-webkit-keyframes fadein {
            from {
                bottom: 0;
                opacity: 0;
            }

            to {
                bottom: 30px;
                opacity: 1;
            }
        }

        @keyframes fadein {
            from {
                bottom: 0;
                opacity: 0;
            }

            to {
                bottom: 30px;
                opacity: 1;
            }
        }

        @-webkit-keyframes fadeout {
            from {
                bottom: 30px;
                opacity: 1;
            }

            to {
                bottom: 0;
                opacity: 0;
            }
        }

        @keyframes fadeout {
            from {
                bottom: 30px;
                opacity: 1;
            }

            to {
                bottom: 0;
                opacity: 0;
            }
        }

        @media print {

            html, body, div {
                margin: 0;
                padding: 0;
                border: 0;
                font-size: 100%;
                font: inherit;
                vertical-align: baseline;
            }

                body * {
                    display: none;
                }

                div.bodyDiv,
                #bodyTable,
                #bodyTable > tbody,
                #bodyTable > tbody > tr,
                #bodyCell,
                #contentWrapper,
                #printImages,
                #printImages *,
                td.noSidebarCell {
                    display: block;
                    margin: 0;
                    padding: 0;
                    border: 0;
                    font-size: 100%;
                    font: inherit;
                    vertical-align: baseline;
                }

                    #printImages > img, #printImages > svg {
                        /* border: 1px solid gray; */
                    }

            * {
                box-shadow: none;
            }

            #printImages > br {
                display: none;
            }

            img, svg {
                page-break-inside: avoid;
                page-break-after: always;
            }

            @page {
                margin: 1cm;
                -webkit-transform: rotate(-90deg);
                -moz-transform: rotate(-90deg);
                filter: progid:DXImageTransform.Microsoft.BasicImage(rotation=3);
            }
        }

        .modalDialog {
            position: fixed;
            font-family: Arial, Helvetica, sans-serif;
            top: 0;
            right: 0;
            bottom: 0;
            left: 0;
            background: rgba(224, 222, 222, 0.8);
            z-index: 99999;
            opacity:0;
            -webkit-transition: opacity 400ms ease-in;
            -moz-transition: opacity 400ms ease-in;
            transition: opacity 400ms ease-in;
            pointer-events: none;
        }
        .modalDialog:target {
            opacity:1;
            pointer-events: auto;
        }
        .modalDialog > div {
            width: 600px;
            height: 200px;
            position: relative;
            margin: 10% auto;
            padding: 5px 20px 13px 20px;
            border-radius: 10px;
            background: #fff;
            background: -moz-linear-gradient(#fff, #999);
            background: -webkit-linear-gradient(#fff, #999);
            background: -o-linear-gradient(#fff, #999);
        }
        .searchClose {
            background: #606061;
            color: #FFFFFF;
            line-height: 25px;
            position: absolute;
            right: -12px;
            text-align: center;
            top: -10px;
            width: 24px;
            text-decoration: none;
            font-weight: bold;
            -webkit-border-radius: 12px;
            -moz-border-radius: 12px;
            border-radius: 12px;
            -moz-box-shadow: 1px 1px 3px #000;
            -webkit-box-shadow: 1px 1px 3px #000;
            box-shadow: 1px 1px 3px #000;
        }
        .searchClose:hover { background: #00d9ff; }
    </style>

    <div style="display:none;" id="inactiveTimeoutWarning">{!$Label.Inactive_Warning}</div>
    <div style="display:none;" id="notFirstEditor">{!$Label.Not_First_Editor}</div>

    <apex:form style="width:98%">
        <apex:outputPanel >
            <div>
                <div class="fullWidth">
                    <div class="topRow">
                        <ul id="menu">
                            <li>
                                <div class="menu-section">File&nbsp;</div>
                                <ul>
                                    <li class="no-read-only"><div onclick="SaveDiagram(false);">Save</div></li>
                                    <li class="no-read-only"><div onclick="j$('#saveAsDialog').dialog('open');">Save As...</div></li>
                                    <li class="no-read-only"><div onclick="SaveDiagram(true);return false;">Save &amp; Close</div></li>
                                    <li>-</li>
                                    <li><div onclick="PrintImages();">Print</div></li>
                                    <li><div onclick="window.open('../apex/displayMachine?id={!MachineId}', '_blank');">Print All Sections</div></li>
                                    <li>-</li>
                                    <li><div onclick="CloseDiagram();">Close</div></li>
                                    <li><div onclick="ReloadDiagram();">Reload</div></li>
                                </ul>
                            </li>
                            <li>
                                <div class="menu-section">Edit&nbsp;</div>
                                <ul>
                                    <li class="no-read-only"><div onclick="diagram.commandHandler.undo();">Undo</div></li>
                                    <li class="no-read-only"><div onclick="diagram.commandHandler.redo();">Redo</div></li>
                                    <li>-</li>
                                    <li class="no-read-only"><div onclick="diagram.commandHandler.cutSelection();">Cut</div></li>
                                    <li class="no-read-only"><div onclick="diagram.commandHandler.copySelection();">Copy</div></li>
                                    <li class="no-read-only"><div onclick="diagram.commandHandler.pasteSelection();">Paste</div></li>
                                    <li class="no-read-only"><div onclick="CopyMetadata();">Copy Metadata</div></li>
                                    <li class="no-read-only"><div onclick="PasteMetadata();">Paste Metadata</div></li>
                                    <li class="no-read-only"><div onclick="diagram.commandHandler.deleteSelection();">Delete</div></li>
                                    <li>-</li>
                                    <li class="no-read-only"><div onclick="diagram.commandHandler.groupSelection();">Group</div></li>
                                    <li class="no-read-only"><div onclick="diagram.commandHandler.ungroupSelection();">Ungroup</div></li>
                                    <li><div onclick="diagram.commandHandler.selectAll();">Select All</div></li>
                                    <li class="no-read-only"><div onclick="ClearAll();">Clear</div></li>
                                </ul>
                            </li>
                            <li>
                                <div class="menu-section">View&nbsp;</div>
                                <ul>
                                    <li><div onclick="NavigateToSection('{!MachineSectionId}');">Refresh</div></li>
                                    <li>-</li>
                                    <li><div onclick="diagram.commandHandler.increaseZoom();">Zoom In</div></li>
                                    <li><div onclick="diagram.commandHandler.decreaseZoom();">Zoom Out</div></li>
                                    <li><div onclick="diagram.commandHandler.resetZoom();">Reset Zoom</div></li>
                                    <li><div onclick="diagram.commandHandler.zoomToFit();">Zoom to Fit</div></li>
                                    <li>-</li>
                                    <li>
                                        <label>
                                            <input id="snap" type="checkbox" onclick="UpdateGridOption();" />
                                            Grid Snap
                                        </label>
                                    </li>
                                </ul>
                            </li>
                            <li>
                                <div class="menu-section">Tools&nbsp;</div>
                                <ul>
                                    <li class="no-read-only" onclick="FlipH();"><div>Flip Horizontally</div></li>
                                    <li class="no-read-only" onclick="FlipV();"><div>Flip Vertically</div></li>
                                    <li>-</li>
                                    <li class="no-read-only" onclick="AlignSelection('horizontal');"><div>Align Horizontal</div></li>
                                    <li class="no-read-only" onclick="AlignSelection('vertical');"><div>Align Vertical</div></li>
                                </ul>
                            </li>

                            <apex:outputText escape="false">
                                <li>
                                    <div class="menu-section">Machine Sections&nbsp;</div>
                                    <ul>
                                        <apex:repeat value="{!MachineSections}" var="section">
                                            <apex:outputText rendered="{!section.Id = MachineSectionId}">
                                                <li class="ui-state-disabled">
                                                    <div>
                                                        {!section.Name}
                                                    </div>
                                                </li>
                                            </apex:outputText>
                                            <apex:outputText rendered="{!section.Id != MachineSectionId}">
                                                <li>
                                                    <div onclick="NavigateToSection('{!section.Id}');">
                                                        {!section.Name}
                                                    </div>
                                                </li>
                                            </apex:outputText>
                                        </apex:repeat>
                                    </ul>
                                </li>
                            </apex:outputText>
                            <li>
                                <label class="shiftRight">
                                    <apex:outputText rendered="{!IsReadOnly = false}">
                                        <input type="checkbox" checked="checked" id="palette_cb" onclick="HideShow('#palette_cb', '#palette', this);" />
                                    </apex:outputText>
                                    <apex:outputText rendered="{!IsReadOnly = true}">
                                        <input type="checkbox" disabled="disabled" />
                                    </apex:outputText>
                                    <span class="valignTop">Palette&nbsp;</span>
                                </label>
                            </li>
                            <li>
                                <label>
                                    <input type="checkbox" checked="checked" id="metadata_cb" onclick="HideShow('#metadata_cb', '#metadataGroup', this);" />
                                    <span class="valignTop">{!$Label.Metadata_Name}&nbsp;</span>
                                </label>
                            </li>
                            <li>
                                <label>
                                    <input id="grid" type="checkbox" onclick="UpdateGridOption();" />
                                    <span class="valignTop">Grid Lines&nbsp;</span>
                                </label>
                            </li>
                        </ul>
                    </div>

                    <div class="topRow topSpacer"></div>

                    <div id="toolbar" class="toolbar topRow initiallyHidden">
                        <label onclick="SaveDiagram(false);" title="Save Machine Map" class="no-read-only">
                            <a href="#"><i class="fa fa-floppy-o fa-lg" aria-hidden="true"></i></a>
                        </label>

                        <label onclick="CloseDiagram();" title="Close" class="no-read-only">
                            <a href="#"><i class="fa fa-window-close fa-lg" aria-hidden="true"></i></a>
                        </label>

                        <label onclick="diagram.commandHandler.undo();" title="Undo Last Edit" class="no-read-only">
                            <a href="#"><i class="fa fa-undo fa-lg" aria-hidden="true"></i></a>
                        </label>

                        <label onclick="diagram.commandHandler.redo();" title="Redo Last Edit" class="no-read-only">
                            <a href="#"><i class="fa fa-repeat fa-lg" aria-hidden="true"></i></a>
                        </label>

                        <label onclick="diagram.commandHandler.cutSelection();" title="Cut Selection" class="no-read-only">
                            <a href="#"><i class="fa fa-cut fa-lg" aria-hidden="true"></i></a>
                        </label>

                        <label onclick="diagram.commandHandler.copySelection();" title="Copy Selection">
                            <a href="#"><i class="fa fa-copy fa-lg" aria-hidden="true"></i></a>
                        </label>

                        <label onclick="diagram.commandHandler.pasteSelection();" title="Paste Copied Selection" class="no-read-only">
                            <a href="#"><i class="fa fa-paste fa-lg" aria-hidden="true"></i></a>
                        </label>

                        <label onclick="CopyMetadata();" title="Copy Metadata">
                            <a href="#"><i class="fa fa-cog fa-lg" aria-hidden="true"></i></a>
                        </label>

                        <label onclick="PasteMetadata();" title="Paste Metadata" class="no-read-only">
                            <a href="#"><i class="fa fa-cogs fa-lg" aria-hidden="true"></i></a>
                        </label>

                        <label onclick="diagram.commandHandler.deleteSelection();" title="Delete Selection" class="no-read-only">
                            <a href="#"><i class="fa fa-remove fa-lg" aria-hidden="true"></i></a>
                        </label>

                        <label onclick="diagram.commandHandler.decreaseZoom();" title="Zoom Out">
                            <a href="#"><i class="fa fa-search-minus fa-lg" aria-hidden="true"></i></a>
                        </label>

                        <label onclick="diagram.commandHandler.increaseZoom();" title="Zoom In">
                            <a href="#"><i class="fa fa-search-plus fa-lg" aria-hidden="true"></i></a>
                        </label>

                        <label onclick="diagram.commandHandler.zoomToFit();" title="Zoom to Fit">
                            <a href="#"><i class="fa fa-arrows fa-lg" aria-hidden="true"></i></a>
                        </label>

                        <label onclick="FlipH();" title="Flip Horizontal" class="no-read-only">
                            <a href="#"><i class="fa fa-exchange fa-lg" aria-hidden="true"></i></a>
                        </label>

                        <label onclick="FlipV();" title="Flip Vertical" class="no-read-only">
                            <a href="#"><i class="fa fa-exchange fa-rotate-90 fa-lg" aria-hidden="true"></i></a>
                        </label>

                    </div>
                </div>

                <div class="mainBlock">
                    <apex:outputText escape="false" rendered="{!IsReadOnly = false}">
                        <div id="closeDialog" title="Close Section Map...">
                            <p>
                                {!$Label.Close_Map_Modified}
                            </p>

                            <input type="button" value="Yes" onclick="SaveDiagram(true);" />&nbsp;
                            <input type="button" value="No" onclick="NavigateToRetUrl(true);" />&nbsp;
                            <input type="button" value="Cancel" onclick="j$('#closeDialog').dialog('close');" />
                        </div>

                        <div id="saveAsDialog" title="Save As...">
                            <apex:outputText value="{!$Label.Save_As_Directions}" rendered="{!$Label.Save_As_Directions != '(empty)'}" />
                            <br /><br />
                            <input type="text" maxlength="{!MaxSectionNameLength}" id="newSectionName" />
                            <br /><br />
                            <input type="button" value="Create" id="saveAsCreate" onclick="SaveDiagramAs();" />
                            <input type="button" value="Cancel" id="saveAsCancel" onclick="j$('#saveAsDialog').dialog('close');" />
                        </div>

                        <div id="toast"></div>

                        <div id="palette" class="initiallyHidden">
                            <apex:repeat value="{!PaletteGroupKeys}" var="pg">
                                <apex:outputText rendered="{!pg != 'Roll' && pg != 'Belt'}">

                                    <!-- palette group header: name and checkbox for visible -->
                                    <h3>
                                        <span class="inline">
                                            <span>
                                                {!KeyToName[pg]}
                                            </span>
                                            <span class="floatRight">
                                                <input id="cb_{!pg}" type="checkbox" class="cb_visible" />
                                            </span>
                                        </span>
                                    </h3>

                                    <div>
                                        <div id="myPalette{!pg}" class="height360"></div>
                                    </div>
                                </apex:outputText>
                            </apex:repeat>

                            <h3>
                                <a href="#">
                                    Notes, Arrows &amp; Lines
                                    <span class="floatRight">
                                        <label id="label_Notes">
                                            <input id="cb_Notes" type="checkbox" class="cb_visible" />
                                        </label>
                                    </span>
                                </a>
                            </h3>
                            <!-- div with id for this palette group -->
                            <div>
                                <div id="myPaletteNotes" class="height360"></div>
                            </div>

                            <h3><a href="#">Rolls</a></h3>
                            <div><div id="myPaletteRoll" class="height360"></div></div>

                            <h3><a href="#">Belt</a></h3>
                            <div><div id="myPaletteBelt" class="height360"></div></div>
                        </div>
                    </apex:outputText>

                    <div id="diagramDiv" class="topBox"></div>

                    <div id="metadataGroup" class="topBox">
                    </div>
                </div>
            </div>
            <div id="searchModal" class="modalDialog">
            </div>
        </apex:outputPanel>
    </apex:form>
    <div id="printImages"></div>
    <div id="saveOverlay">
        <div id="overLayText">Saving...</div>
    </div>
    <div id="ShowerModalWindow" class="shower-modal">        
        <div id="ShowerContainer" class="shower-content">
            <span class="shower-close">&times;</span>
        </div>
    </div>

    <script>
        var debug = 0;
        var diagram = null;
        var docImages = null;
        var configs = null;

        var highlights = [];

        var ARROW_DEFAULT_SIZE = 48;
        var ARROW_WIDTH_NORMAL = 1.25;
        var ARROW_HEAD_WIDTH = 6;

        var BELT_WIDTH_NORMAL = 2.5;
        var BELT_DASH_NORMAL = null;

        var BELT_WIDTH_ERROR = 5.0;
        var BELT_DASH_ERROR = [10, 2];

        var DEFAULT_LOCATION = "100 500";

        var COLOR_SELECTED = "dodgerblue";
        var COLOR_ERROR = "red";
        var COLOR_ERROR2 = "darkred";
        var COLOR_NORMAL = "black";

        var WIDTH_SELECTED = 4;
        var WIDTH_ERROR = 5;
        var WIDTH_NORMAL = 1;

        var PICKLIST_UNSET = '(not set)';

        var ARROW_TYPE = "Triangle";
        var ARROW_NONE = "None";

        var maxStringSize = 6000000;    // Maximum String size is 6,000,000 characters
        var maxFileSize = 4350000;      // After Base64 Encoding, this is the max file size
        var chunkSize = 950000;         // Maximum Javascript Remoting message size is 1,000,000 characters
        var uploadIndex = 0;

        var metadata;
        var metadataVals = new Object();
        var partFieldPartOptions;
        var partFieldDescOptions;
        var partFieldCustOptions;
        var recordTypes;
        var deletedNodes = [];
        var diagramDirty = false;
        var wasDirty = false;
        var isSheetPath = false;
        var isBladeCabinetSection = "false";
        var viewBoundsHeight = 0;

        var printing = false;
        var printIncludeWatermarks = true;

        var copyMetadataKey;

        var userPrefs;
        var palettePrefNames = [];

        var resetWatermarks = true;
        var loading = false;
        var updatingMetadata = false;
        var returnAfterSave = false;

        var dragDropSupported;

        var idToNodeKey = new Object();
        var j$ = jQuery.noConflict();
        var g$ = go.GraphObject.make;

        var PREF_GRID = "Grid Settings"; // show|snap
        var PREF_SHOW_PALETTE = "Show Palette";
        var PREF_SHOW_METADATA = "Show Metadata";
        var FILTER_CLASS = "Machine_Mapping_Filter__c";

        var editTimeout = {!EditTimeout} * 60 * 1000;
        var editTimeoutWarn = {!EditTimeoutWarn} * 60 * 1000;
        var editorStillActive = true;
        var lastActiveTime;
        var didInactiveWarning = false;
        var resetEditing = false;
        var editInfoTimer;
        var inactiveWarnTimer;
        var inactiveWarnTitle;

        var GradientLightGray = g$(go.Brush, "Linear", { 0: "White", 1: "#DADADA" });

        var lcHost = "{!$CurrentPage.parameters.lcHost}";
        var vfHost = getHost('{!$CurrentPage.URL}', '/');

        var imageInfos = [];

        var dynamicLineSelected = false;
        
        var vfcomponents = {};
        var showerSpan = document.getElementsByClassName("shower-close")[0];

        showerSpan.onclick = function() {
            vfcomponents.destroy();//Destroy Previous component 
            document.getElementById("ShowerContainer").style.display = "none";
            document.getElementById("ShowerModalWindow").style.display = "none";
        }

        function saveOn() {
            document.getElementById("saveOverlay").style.display = "block";
        }

        function saveOff() {
            document.getElementById("saveOverlay").style.display = "none";
        }        

        function calculatePopUp(thisShowerId) {
            //console.log("In the Calc function!!, shower ID: " + thisShowerId);                
            document.getElementById("ShowerModalWindow").style.display = "block";
            $Lightning.use("c:ShowerCalculatorAura", function() {
                var modalBody;
                document.getElementById("ShowerContainer").style.display = "block";
                $Lightning.createComponent("c:showerCalculation",
                    { 'showerID' : thisShowerId, 'showTitle' : true },
                    "ShowerContainer",
                    function(content, status) {
                        if (status === "SUCCESS")
                        {
                            modalBody = content;
                            vfcomponents = content;
                        }
                        //console.log("button was created");                                        
                        // do some stuff
                    }
                );
            });
        }        

        j$(window).on("load", function()
        {
            //console.log('In Load 1');
            if (diagram != null)
            {
                var editInfo = JSON.parse('{!LastEditInfo}');
                if (editInfo && editInfo.name)
                {
                    var text = j$("#notFirstEditor").text();

                    text = text.replace("(user)", editInfo.name);

                    j$("#notFirstEditor").text(text);

                    j$("#notFirstEditor").dialog
                    ({
                        modal: true,
                        buttons:
                        [{
                            text: "OK",
                            click: function() {j$(this).dialog("close");}
                        }]
                    });
                }

                diagram.startTransaction("json load");
                LoadJson();
                ResetMetadataPanel();
                diagram.commitTransaction("json load");

                setTimeout (FixHeight, 1);

                UpdateEditInfo();
            }
            j$(window).resize(function() { FixHeight(); } );
            //console.log('Done Load 2');
        });

        j$(document).ready(function()
        {
            isSheetPath = false;
            var testDiv = document.createElement('div');
            dragDropSupported = (('draggable' in testDiv) || ('ondragstart' in div && 'ondrop' in testDiv)) &&
                'FormData' in window && 'FileReader' in window;

            if ("{!NoSectionMaps}" == "true")
            {
                alert ("{!$Label.No_Section_Maps}");

                NavigateToRetUrl(false);
                return;
            }

            try
            {
                loading = true;

                InitPrefs();
                InitConfigs();
                InitDocImages();
                InitTypes();
                Init();

                InitMetadata();

                if ({!IsReadOnly})
                    SetReadOnly();

                j$("#newSectionName").keyup(function() { SaveDiagramAsChange(); });
                SaveDiagramAsChange();

                j$("#menu").menu(
                {
                    position: { my: "left top", at: "left top+30" },
                    icons: { submenu: "ui-icon-triangle-1-s" }
                });

                j$("#menu").show();

                j$(".toolbar").controlgroup();
                j$(".toolbar").show();

                HandlePrefs();

                window.addEventListener("message", handleMessage, false);

                sendToLightning("vfHost", vfHost);
                sendToLightning("dirty", false);

                // Remmed out the following line because Palette preferences are handled differently.  SAM 8-AUG-2019
                //j$('.cb_visible').prop('checked', true);
                j$('.cb_visible').click(function(e)
                {
                    e.stopPropagation();

                    var layerName = this.id.substring(3);
                    
                    diagram.startTransaction('toggleVisible ' + layerName);

                    var layer = diagram.findLayer(layerName);

                    if (layer !== null)
                    {
                            layer.visible = e.currentTarget.checked;
                    }

                    diagram.commitTransaction('toggleVisible ' + layerName);

                    if ((!loading) && (layer !== null))
                    {
                        UpdatePreference("PALETTE_HIDE_" + layerName, e.currentTarget.checked);
                    }
                });

                j$("#saveAsDialog").dialog(
                {
                    autoOpen: false,
                    modal: true
                });

                // sfdc sidebar was shown/hidden
                j$("#handlebarContainer").click(function()
                {
                    FixWidth();
                });
            }
            catch (ex)
            {
                alert ("Error loading page: " + ex.message);
            }
            loading = false;
            //console.log('Out of Ready 4');
        });

        j$(window).on('beforeunload', function()
        {
            //console.log("beforeunload");

            var dirty = diagramDirty;

            for (var it = diagram.nodes; !dirty && it.next() ; )
            {
                var node = it.value;
                if (node instanceof go.Node && node.data.dirty)
                    dirty = true;
            }

            resetEditing = dirty;

            //console.log("beforeunload: dirty = " + dirty);

            if (!{!IsReadOnly})
            {
                ClearEditInfo("beforeunload", null);
            }

            if (!dirty)
            {
                return undefined; // no prompt
            }
            else
            {
                return 'The machine map has changed. Are you sure you want to leave without saving?';
            }
        });

        function StillActive()
        {
            diagram.startTransaction ('still active');
            editorStillActive = true;

            if (resetEditing)
            {
                // don't wait - update stuff right away
                console.log("fast editinfo update");
                UpdateEditInfo();
            }
            diagram.commitTransaction ('still active');
        }

        function ClearEditInfo(title, callback)
        {
            if (editTimeout > 0)
            {
                //console.log(title + ": clearing editInfo");
                Visualforce.remoting.Manager.invokeAction
                (
                    '{!$RemoteAction.MachineSectionMapController.ClearEditInfo}',
                    '{!MachineSectionId}',
                    function(result, event)
                    {
                        //console.log(title + ": cleared editInfo");
                        if (callback)
                        {
                            callback();
                        }
                    }
                );
                setTimeout( function() {console.log("timeout callback");} , 1000);
            }
            else
            {
                if (callback)
                    callback();
            }
        }

        function UpdateEditInfo()
        {
            //console.log("UpdateEditInfo");
            if (editInfoTimer)
            {
                clearTimeout(editInfoTimer);
                editInfoTimer = null;
            }

            editorStillActive |= resetEditing;

            if (!{!IsReadOnly} && editTimeout > 0)
            {
                var wasActive = editorStillActive;
                editorStillActive = false;
                resetEditing = false;

                if (wasActive)
                {
                    //console.log("updating editInfo");

                    lastActiveTime = Date.now();
                    didInactiveWarning = false;

                    ClearFlashy();

                    Visualforce.remoting.Manager.invokeAction
                    (
                        '{!$RemoteAction.MachineSectionMapController.UpdateEditInfo}',
                        '{!MachineSectionId}',
                        function(result, event)
                        {
                            editInfoTimer = setTimeout(UpdateEditInfo, 1000 * 15);
                        }
                    );
                }
                else
                {
                    var now = Date.now();
                    var max = lastActiveTime + editTimeout;
                    var warn = lastActiveTime + editTimeoutWarn;

                    //console.log("Not updating editInfo - warn=" + (warn - now) + ", max=" + (max - now));

                    if (now > max)
                    {
                        //console.log("past max inactive time - logout!");

                        ClearFlashy();

                        ClearEditInfo("logout", NavigateToRetUrlForced);
                    }
                    else
                    if (now > warn)
                    {
                        if (!didInactiveWarning)
                        {
                            //console.log("inactive timeout warning!");
                            didInactiveWarning = true;

                            ClearFlashy();

                            inactiveWarnTitle = document.title;
                            inactiveWarnTimer = setInterval(function()
                            {
                                // not supported on all browsers (and/or lex may not like it) but
                                // this will flash the taskbar to make things more noticable
                                if (document.title == inactiveWarnTitle)
                                    document.title = inactiveWarnTitle + " ";
                                else
                                    document.title = inactiveWarnTitle;
                            }, 1000);


                            j$("#inactiveTimeoutWarning").dialog
                            ({
                                modal: true,
                                close: function(event, ui)
                                {
                                    StillActive();
                                },
                                buttons:
                                [{
                                    text: "Continue Working",
                                    click: function() {j$(this).dialog("close");}
                                }],
                                classes:
                                {
                                    "ui-dialog": "red-border",
                                    "ui-dialog-titlebar": "red-background",
                                }
                            });
                        }
                        else
                        {
                            //console.log("already warned..");
                        }
                    }
                    editInfoTimer = setTimeout(UpdateEditInfo, 1000 * 15);
                }
            }
        }

        function ClearFlashy()
        {
            if (inactiveWarnTimer)
            {
                clearInterval(inactiveWarnTimer);
                inactiveWarnTimer = null;
                document.title = inactiveWarnTitle;
            }
        }

        function HandlePrefs()
        {
            var pref = userPrefs[PREF_GRID];
            if (pref)
            {
                var tmp = pref.split("|");

                j$("#grid").prop("checked", tmp[0] == "true");
                j$("#snap").prop("checked", tmp[1] == "true");
                UpdateGridOption();
            }

            pref = userPrefs[PREF_SHOW_PALETTE];
            if (pref)
            {
                j$("#palette_cb").prop("checked", pref == "true");
                HideShow("#palette_cb", "#palette", null);
            }

            pref = userPrefs[PREF_SHOW_METADATA];
            if (pref)
            {
                j$("#metadata_cb").prop("checked", pref == "true");
                HideShow("#metadata_cb", "#metadataGroup", null);
            }

            for (var i = 0; i < palettePrefNames.length; i++)
            {
                var paletteName = palettePrefNames[i];
                var prefKey = "PALETTE_HIDE_" + paletteName;
                var chkBox = "#cb_" + paletteName;
                pref = userPrefs[prefKey];
                if (pref)
                {
                    if (pref == "false")
                    {                                   
                        j$(chkBox).prop("checked", false);
                        var layer = diagram.findLayer(paletteName);
                        if (layer !== null)
                        {
                                layer.visible = false;
                        }
                    }
                    else
                        j$(chkBox).prop("checked", true);
                }
                else
                {
                    j$(chkBox).prop("checked", true);
                }
            }
        }

        function MakeSObject(node)
        {
            var data = node.data;
            var so = new sforce.SObject(data.sObjectType);

            if (!data.objectId)
            {
                // no object id = insert; set type and record type
                so.Machine_Section__c = '{!MachineSectionId}';
                so.RecordTypeId = recordTypes[data.recordType];
            }
            else
            {
                // have an object id = update; just set the id
                so.Id = data.objectId;
            }

            // include associated metadata fields
            var metas = metadataVals[data.key];
            if (metas)
            {
                var metadataDefs = metadata[data.recordType];

                for (var meta in metas)
                {
                    var metadataDef = null;
                    for (var i = 0; i < metadataDefs.length && metadataDef == null; i++)
                    {
                        // todo: direct index instead of loop
                        if (metadataDefs[i].path == meta)
                            metadataDef = metadataDefs[i];
                    }

                    if (metadataDef && !metadataDef.isReadOnly)
                    {
                        if (metadataDef.picks && metadataDef.picks.length > 0 && metas[meta] == PICKLIST_UNSET)
                        {
                            SetSoField(so, meta, null);
                        }
                        else
                        if (metadataDef.isCheckbox)
                        {
                            var val = metas[meta];
                            if (val == "true")
                                val = true;
                            else
                            if (val == "false")
                                val = false;

                            so.set(meta, val);
                        }
                        else
                        {
                            SetSoField(so, meta, metas[meta]);
                        }
                    }
                }
            }
            return so;
        }

        function SetSoField (so, fieldName, val)
        {
            if (val != null && val != "")
                so[fieldName] = val;
            else
            if (so.fieldsToNull == null)
                so.fieldsToNull = [fieldName];
            else
                so.fieldsToNull.push (fieldName);
        }

        function ReloadDiagram()
        {
            diagramDirty = false;

            for (var it = diagram.nodes; it.next() ; )
            {
                var node = it.value;
                if (node instanceof go.Node && node.data.dirty)
                    node.data.dirty = false;
            }

            ClearEditInfo("reloadDiagram", function() { NavigateToSection("{!MachineSectionId}"); });
        }

        function CloseDiagram()
        {
            // if they edited metadata but haven't moved off it, force an update
            var focus = j$('input:focus');
            if (focus && focus.length > 0)
            {
                if (!UpdateMetadataValue (focus[0]))
                {
                    // validation (numeric field) fail.. we've already done alert() so just return
                    return;
                }
            }

            if (!CheckRequiredFields())
            {
                // some required field is missing.. already done the alert - just return
                return;
            }

            var dirty = diagramDirty;

            for (var it = diagram.nodes; !dirty && it.next() ; )
            {
                var node = it.value;
                if (node instanceof go.Node && node.data.dirty)
                    dirty = true;
            }

            if (dirty)
            {
                var d = j$("#closeDialog").dialog();
            }
            else
            {
                NavigateToRetUrl(false);
            }
        }

        function SaveDiagramAsChange()
        {
            var newName = j$("#newSectionName").val();

            if (!newName || newName == "")
                j$("#saveAsCreate").attr("disabled", true);
            else
                j$("#saveAsCreate").removeAttr("disabled");
        }

        function SaveDiagramAs(name)
        {
            // pop up a modal dialog to get the name of the new diagram them let apex do all the
            // work to clone the machine section and all the parts. once it's done, direct to the
            // new machine section

            var newName = j$("#newSectionName").val();

            Visualforce.remoting.Manager.invokeAction
            (
                '{!$RemoteAction.MachineSectionMapController.CloneMachineSection}',
                '{!MachineSectionId}',
                newName,
                function(result, event)
                {
                    j$("#saveAsDialog").dialog("close");

                    if (event.status && result) // call success
                    {
                        NavigateToSection(result);
                    }
                    else
                    {
                        var msg = "{!$Label.Save_As_Errors}";
                        if (event.message && event.message !== "")
                        {
                            msg += "\n\n" + event.message;
                        }

                        alert (msg);
                    }
                },
                {escape: false}
            );
        }

        function SaveDiagram(andReturn)
        {
            diagram.clearSelection();
            // special case for if the user has updated a metadata field but has not
            // moved off that input yet - the onChange won't have been fired. check if
            // this is the case and force the update if it looks like it changed
            var focus = j$('input:focus');
            if (focus && focus.length > 0)
            {
                if (!UpdateMetadataValue (focus[0]))
                {
                    // validation fail.. we've already done alert() so just return
                    return;
                }
            }

            if (CheckRequiredFields())
            {
                saveOn();
                sforce.connection.sessionId = '{!$Api.Session_ID}';
                returnAfterSave = andReturn;
                SaveDiagramDelete();
                saveOff();
            }
        }

        function CheckRequiredFields()
        {
            for (var it = diagram.nodes; it.next() ; )
            {
                var data = it.value.data;

                if (data.key)
                {
                    var metas = metadataVals[data.key];
                    if (metas)
                    {
                        var metadataDefs = metadata[data.recordType];
                        if (metadataDefs)
                        {
                            for (var i = 0; i < metadataDefs.length; i++)
                            {
                                var def = metadataDefs[i];
                                if (def.isRequired)
                                {
                                    var val = metas[def.path];
                                    if (val == null || val == "" || (def.picks && def.picks.length > 0 && val == PICKLIST_UNSET))
                                    {
                                        diagram.select(it.value);
                                        alert ("{!$Label.Required_Fields_Missing}");

                                        return false;
                                    }
                                }
                            }
                        }
                    }
                }
            }
            return true;
        }
        
        function NodeIsOnDiagram(theObjId)
        {
            var onDiagram = false;
            for (var it = diagram.nodes; it.next() ; )
            {
                var node = it.value;
                var data = node.data;
                if (data.objectId == theObjId)
                {
                    onDiagram = true;
                }
            }
            return onDiagram;
        }

        function SaveDiagramDelete()
        {
            if (deletedNodes.length > 0)
            {
                // Look for deleted nodes that have been Ctrl-Z or the user has pressed the UnDo button                                
                for (var i = 0; i < deletedNodes.length; i++)
                {
                    if (NodeIsOnDiagram(deletedNodes[i]))                                   
                    {
                        deletedNodes.pop(deletedNodes[i]);
                        //console.log("Poped a deleted node off of list");                                                                                                   
                    }
                }
                Visualforce.remoting.Manager.invokeAction
                (
                    '{!$RemoteAction.MachineSectionMapController.RemoveParts}',
                    deletedNodes,
                    function(result, event)
                    {
                        if (event.status) // call success
                        {
                            if (!result) // = errors
                            {
                                alert ("{!$Label.Part_Deletes_Failed}");
                            }
                            else
                            {
                                SaveDiagramInsert();
                            }
                        }
                        else
                        {
                            alert ("{!$Label.Part_Deletes_Failed}");
                        }
                    },
                    {escape: false}
                );

                deletedNodes = [];
            }
            else
            {
                SaveDiagramInsert();
            }
        }

        function SortNodes(nodes)
        {
            var all = new Object();

            for (var i = 0; i < nodes.length; i++)
            {
                var n = nodes[i];
                var t = n.so.type;

                var prevList = all[t];
                if (prevList == null)
                {
                    prevList = [];
                    all[t] = prevList;
                }
                prevList.push (n);
            }

            var ret = [];

            for (var typeName in all)
            {
                var typeList = all[typeName];

                for (var j = 0; j < typeList.length; j++)
                {
                    ret.push (typeList[j]);
                }
            }

            return ret;
        }

        function SaveDiagramInsert()
        {
            var allInserts = [];

            for (var it = diagram.nodes; it.next() ; )
            {
                var node = it.value;
                var data = node.data;                

                if (data && data.dirty)
                {
                    if (data.sObjectType && !data.objectId)
                    {
                        var so = MakeSObject (node);

                        // exception if we pass this on insert.. if we just set it
                        // to null, it still gets sent - do a hard delete on it
                        delete so.fieldsToNull;

                        allInserts.push({so: so, node: node});
                    }
                }
                else
                {
                    data.dirty = false;
                }
            }

            updateDirty();

            if (allInserts.length > 0)
            {
                var inserts = [];
                var insertNodes = [];

                allInserts = SortNodes(allInserts);

                for (var i = 0; i < allInserts.length; i++)
                {
                    var x = allInserts[i];

                    inserts.push (x.so);
                    insertNodes.push (x.node);
                }

                Visualforce.remoting.Manager.invokeAction
                (
                    '{!$RemoteAction.MachineSectionMapController.InsertParts}',
                    JSON.stringify(inserts),
                    function(result, event)
                    {
                        if (event.status) // success
                        {
                            var errors = "";
                            var results = JSON.parse (result);

                            for (var i = 0; i < results.length; i++)
                            {
                                //console.log ('create result ' + i + ' = ' + results[i]);

                                var node = insertNodes[i];
                                if (results[i].success)
                                {
                                    node.data.dirty = false;
                                    node.data.objectId = results[i].id;

                                    metadataVals[node.data.key] = null;

                                    // special case when inserting something that's snapped to another
                                    // node: make sure we also do an update on this one to get the lookup
                                    // to what we're snapped to correct
                                    if (node.data.snappedTo)
                                    {
                                        node.data.dirty = true;
                                        node.data.snapChange = true;
                                    }
                                }
                                else
                                {
                                    errors += (errors == "" ? "" : "\n") + results[i].errors.message;
                                }
                            }

                            if (errors != "")
                                alert ("{!$Label.Did_Not_Save_All}\n\n" + errors);

                            updateDirty();
                            SaveDiagramUpdates();
                        }
                        else
                        {
                            var msg = event.message;
                            var strip = "first error: "; // todo: others? maybe an array of strings with a loop
                            var pos = msg.indexOf(strip);
                            if (pos != -1)
                                msg = msg.substring (pos + strip.length);

                            alert ("{!$Label.Cannot_Save}\n\n" + msg);
                        }
                    },
                    {escape: false}
                );
            }
            else
            {
                SaveDiagramUpdates();
            }
        }

        function SaveDiagramUpdates()
        {
            // saveOn();    Moving to Save Diagram
            var allUpdates = [];
            
            for (var it = diagram.nodes; it.next() ; )
            {
                var node = it.value;
                var data = node.data;                      
                
                // Add new properties to support the actual coordinates of the Doctor for the Blade Cabinet
                // Added by SAM 16-NOV-2020
                if (node.data.objectType == "Doctor")
                {
                    var docloc = diagram.transformDocToView(node.location);
                    node.data.doclocx = docloc.x;
                    node.data.doclocy = docloc.y;                    
                }

                if (data && (data.dirty || data.snapChange || data.filterChange))
                {
                    if (data.sObjectType && data.objectId)
                    {
                        var so = MakeSObject (node);

                        allUpdates.push ( { so: so, node: node} );
                    }
                    else
                    {
                        data.dirty = false;
                        data.snapChange = false;
                        data.filterChange = false;
                    }
                }
            }
            
            updateDirty();

            if (allUpdates.length > 0)
            {
                var updates = [];
                var updateNodes = [];

                allUpdates = SortNodes(allUpdates);

                for (var i = 0; i < allUpdates.length; i++)
                {
                    var x = allUpdates[i];

                    updates.push (x.so);
                    updateNodes.push (x.node);
                }

                for (var i = 0; i < updates.length; i++)
                {
                    //console.log ('updating ' + updates[i]);

                    var node = updateNodes[i];
                    var data = node.data;

                    if (data.filterChange)
                    {
                        var so = updates[i];
                        var config = GetConfig(node.data.recordType);
                        var filterField = config.Filter_Field__c;

                        var filterKey = data.filterNumber;
                        if (filterKey)
                        {
                            // link (still) exists
                            var filterNode = diagram.findNodeForKey(filterKey);

                            so[filterField] = filterNode.data.objectId;
                        }
                        else
                        {
                            // link deleted
                            SetSoField (so, filterField, null);
                        }
                        //console.log("set filter so[" + filterField + "] = " + so[filterField]);
                    }
                    else
                    if (data.snapChange)
                    {
                        var so = updates[i];
                        var lookupField;

                        switch (data.sObjectType)
                        {
                            case "Machine_Mapping_Doctor__c":
                            case "Machine_Mapping_Rotary_Joint__c":
                                lookupField = "Roll__c";
                                break;
                            case "Machine_Mapping_Roll__c":
                                lookupField = "Belt__c";
                                break;                                                
                            case "Machine_Mapping_Accessory__c":
                                lookupField = "Cleaning__c";
                                break;
                        }

                        var snapTo = node.data.snappedTo;
                        if (snapTo && snapTo != "")
                        {
                            var snapNode = diagram.findNodeForKey(snapTo);

                            so[lookupField] = snapNode.data.objectId;
                        }
                        else
                        {
                            SetSoField (so, lookupField, null);
                        }
                        //console.log ('set snap so[' + lookupField + '] = ' + so[lookupField]);
                    }
                }

                sforce.connection.update(updates,
                {
                    onSuccess : function(results, source)
                    {
                        var errors = "";
                        for (var i = 0; i < results.length; i++)
                        {
                            //console.log ('result ' + i + ' = ' + results[i]);

                            var node = updateNodes[i];
                            if (results[i].success == "true")
                            {
                                node.data.dirty = false;

                                metadataVals[node.data.key] = null;

                                if (results[i].created == "true")
                                {
                                    node.data.objectId = results[i].id;
                                }

                                node.data.dirty = false;
                                node.data.snapChange = false;
                                node.data.filterChange = false;
                            }
                            else
                            {
                                errors += (errors == "" ? "" : "\n") + results[i].errors.message;
                            }
                        }

                        updateDirty();

                        if (errors != "")
                            alert ("{!$Label.Did_Not_Save_All}\n\n" + errors);

                        SaveJson();
                    },
                    onFailure : function(error, source)
                    {
                        // nb: this is "the whole call failed" and not "N records failed"
                        //console.log("An error has occurred " + error);

                        alert ('{!$Label.Cannot_Save}');
                    }
                });
            }
            else
            {
                SaveJson();
            }                            
        }

        function LoadMetadata()
        {
            if (diagram.nodes.length == 0)
                return;

            metadataVals = new Object();

            var sobjectTypeToIds = new Object();
            var sotToRt = new Object();
            idToNodeKey = new Object();

            for (var it = diagram.nodes.iterator; it.next() ; )
            {
                var node = it.value;
                var data = node.data;

                if (data && data.sObjectType && data.objectId)
                {
                    var sobjectType = data.sObjectType;

                    idToNodeKey[data.objectId] = node.data.key;

                    var ids = sobjectTypeToIds[sobjectType];
                    if (ids == null)
                        sobjectTypeToIds[sobjectType] = [];

                    sobjectTypeToIds[sobjectType].push ("'" + data.objectId + "'");

                    if (sotToRt[sobjectType] == null)
                        sotToRt[sobjectType] = new go.Set();

                    sotToRt[sobjectType].add(data.recordType);
                }
            }

            sforce.connection.sessionId = '{!$Api.Session_ID}';

            for (var sot in sobjectTypeToIds)
            {
                var ids = sobjectTypeToIds[sot].join();

                //console.log ('type ' + sot + ' ids = ' + ids);

                var fields = new go.Set();

                fields.add("Id");
                fields.add("RecordType.Name");

                for (var it = sotToRt[sot].iterator; it.next() ; )
                {
                    var rt = it.value;
                    var m = metadata[rt];
                    for (var i = 0; i < m.length; i++)
                    {
                        fields.add (m[i].path);
                    }
                }

                var soql = "";
                for (var it = fields.iterator; it.next() ; )
                {
                    if (soql != "")
                        soql += ",";

                    soql += it.value;
                }

                soql = "SELECT " + soql + " FROM " + sot + " WHERE Id IN (" + ids + ")";
                //console.log('SOQL ' + soql);

                var result = sforce.connection.query(soql,
                {
                    onSuccess : function(results, source)
                    {
                        if (results.records instanceof Array)
                        {
                            for (var i = 0; i < results.records.length; i++)
                            {
                                SaveMetadataVals(results.records[i]);
                            }
                        }
                        else
                        {
                            SaveMetadataVals(results.records);
                        }
                    },

                    onFailure : function(error, source)
                    {
                        console.log ('metadata values load failed: ' + error);
                        debugger;
                    }
                });
            }
        }

        function SaveMetadataVals (rec)
        {
            var id = rec.Id;
            var key = idToNodeKey[id];
            var rt = rec.RecordType.Name;
            var node = diagram.findNodeForKey(key);

            var metas = metadata[rt];
            var vals = new Object();

            metadataVals[key] = vals;

            for (var i = 0; i < metas.length; i++)
            {
                var meta = metas[i];
                var path = meta.path;
                var val = rec[path];

                vals[path] = val;
                HandleSpecialCases(node, path, val);
            }
        }

        function LoadJson()
        {
            sforce.connection.sessionId = '{!$Api.Session_ID}';

            var result = sforce.connection.query("SELECT Id, Has_Blade_Cabinet__c, JSON__c FROM Machine_Section__c WHERE ID = '{!MachineSectionId}' LIMIT 1",
            {
                onSuccess : function(results, source)
                {
                    var record = results.records;
                    if (record && record.JSON__c != null)
                    {
                        //console.log ('loading json: ' + record.JSON__c);

                        diagram.model = go.Model.fromJson(record.JSON__c);
                        isBladeCabinetSection = record.Has_Blade_Cabinet__c;
                        //console.log('Blade Cabinet Section? ' + isBladeCabinetSection);

                        PostLoadCleanup();

                        var ids = [];
                        for (var it = diagram.nodes; it.next() ; )
                        {
                            if (it.value.data.objectId)
                                ids.push (it.value.data.objectId);
                        }

                        Visualforce.remoting.Manager.invokeAction
                        (
                            '{!$RemoteAction.MachineSectionMapController.VerifyPartsExist}',
                            '{!MachineSectionId}', ids,
                            function(result, event)
                            {
                                if (event.status) // call success
                                {
                                    //console.log ('event: ' + event);
                                    //console.log ('result: ' + result);

                                    var ret = JSON.parse(result);

                                    var missing = ret['missingText'];
                                    if (missing && missing != '')
                                    {
                                        var missingIds = ret['missingIds'];
                                        missing = '{!$Label.Missing_Parts_Start}\n\n' + missing + '\n\n' + '{!$Label.Missing_Parts_End}';

                                        if (confirm(missing))
                                        {
                                            // recreate parts.. we don't need to do any actual dml here - just
                                            // clear the object id and set dirty on the missing nodes then let
                                            // the existing Save code add them

                                            for (var i = 0; i < missingIds.length; i++)
                                            {
                                                var missingId = missingIds[i];

                                                for (var it = diagram.nodes; it.next() ; )
                                                {
                                                    if (it.value.data.objectId == missingId)
                                                    {
                                                        it.value.data.objectId = null;
                                                        it.value.data.dirty = true;
                                                        break;
                                                    }
                                                }
                                            }

                                            updateDirty();
                                        }
                                        else
                                        {
                                            // remove missing parts from diagram.. again, no dml needed here - just pull
                                            // the nodes out of the diagram and set dirty so we know we need a save

                                            diagram.startTransaction ('remove dead parts');

                                            diagramDirty = true;

                                            for (var i = 0; i < missingIds.length; i++)
                                            {
                                                var missingId = missingIds[i];

                                                for (var it = diagram.nodes; it.next() ; )
                                                {
                                                    if (it.value.data.objectId == missingId)
                                                    {
                                                        diagram.remove (it.value);
                                                        break;
                                                    }
                                                }
                                            }

                                            updateDirty();

                                            diagram.commitTransaction ('remove dead parts');
                                            diagram.undoManager.clear();
                                        }
                                    }
                                }
                                else // VerifyPartsExist fail.. is this even possible?
                                {
                                }
                            },
                            {escape: false}
                        );
                    }
                    else
                    {
                        // fail silently.. the call didn't choke - it just didn't have
                        // any data, which is probably ok for new diagrams
                    }
                },
                onFailure : function(error, source)
                {
                    console.log ('json load failed: ' + error);
                    alert ('{!$Label.Load_Failed}');
                }
            });
        }

        function ResnapNodes()
        {
            for (var it = diagram.nodes; it.next() ; )
            {
                var node = it.value;
                if (node.data && node.data.snappedTo != null)
                {
                    var to = diagram.findNodeForKey (node.data.snappedTo);
                    SnapTo(node, to);
                }
            }
        }

        function PostLoadCleanup()
        {
            for (var it = diagram.nodes; it.next() ; )
            {
                var node = it.value;
                //console.log('node.category: ' + node.category + ", node record type: " + node.data.recordType);

                node.data.dirty = false;

                if (node.category == "roll" && node.data.snapToBelt == null) // upgrade old data
                    node.data.snapToBelt = true;

                if (node.category == "belt")
                {                                    
                    var numGuides = node.data.guides.length;
                    if (node.data.recordType == 'Sheet Path')
                    {
                        numGuides = node.data.guides.length - 1;                                        
                    }
                    for (var i = 0; i < numGuides; i++)
                    {
                        var roll = diagram.findNodeForKey(node.data.guides[i].k);
                        roll.data.onBelt = node.data.key;
                    }
                }

                if (node.data && node.data.name == "Double Arrow" && node.category == "nonresizableArrow")
                {
                    // old 'double arrow' got renamed and a new 'double arrow' got created - rename
                    // old nodes to their new name
                    node.data.name = "Stretch Arrow";
                }

                var tb = node.findObject("PALETTE_LABEL");
                if (tb != null)
                    tb.visible = false;


                var pic = node.findObject('SHAPE');
                if (pic != null)
                {
                    var prev = pic.scale;
                    pic.scale = GetScale(node.data.recordType);
                    //console.log("reset scale from " + prev + " to " + pic.scale);
                }

                SetLinkAllowed(node);
                FixLabel(node);
                SetOutOfService(node);
            }
            ResnapNodes();
            updateDirty();
            
            viewBoundsHeight = diagram.viewportBounds.height;
            //console.log("ViewBounds Height: " + viewBoundsHeight);             
            
            var tmp1 = 1 / diagram.scale;
            var vh = viewBoundsHeight / tmp1;
            //console.log("ViewHeight Scale: " + vh); 
        }

        function SetOutOfService(node) {
            // If the Category is Cleaning and Out of Service is TRUE then set label color to RED
            // Eventually this should be made more universal!!  Not for Cleaning only!!
            if (node.data.objectType == "Cleaning") {
                var label = node.findObject("LABEL");
                var out_of_service = "false";
                var data = node.data;
                var id = data.objectId;    // Cleaning table ID

                sforce.connection.sessionId = '{!$Api.Session_ID}';

                var sqlStr = "SELECT Out_of_Service__c FROM Machine_Mapping_Cleaning__c WHERE Id = '" + id + "'";
                var result = sforce.connection.query(sqlStr);
                var result1 = result.getArray('records');

                //console.log("Cleaning data ID: " + result1[0].Out_of_Service__c);
                out_of_service = result1[0].Out_of_Service__c;

                if (out_of_service == "true") {
                    label.stroke = "red";
                }
            }
        }

        function HideText(node)
        {
            if (node.category == "roll")
            {
            }
            else
            {
                var tb = node.findObject("PALETTE_LABEL");
                if (tb != null)
                    tb.visible = false;
            }
        }

        function SaveJson()
        {
            var jsonStr = diagram.model.toJson();

            //console.log ('saving json: ' + jsonStr);

            sforce.connection.sessionId = '{!$Api.Session_ID}';

            var so = new sforce.SObject('Machine_Section__c');
            so.Id = '{!MachineSectionId}';
            so.JSON__c = jsonStr;
            so.ViewBoundsHeight__c = viewBoundsHeight;

            sforce.connection.update([so],
            {
                onSuccess : function(results, source)
                {
                    //console.log ('result = ' + results);
                    if (results[0].success != "true")
                        alert ("{!$Label.Did_Not_Save_All}");

                    diagramDirty = false;
                    updateDirty();
                    GenerateImages (960, 700, false);

                    if (returnAfterSave)
                        NavigateToRetUrl(false);
                    else
                    {
                        LoadMetadata();
                        //Toast("{!$Label.Section_Map_Saved}");
                    }
                },
                onFailure : function(error, source)
                {
                    console.log("An error has occurred " + error);

                    alert ('{!$Label.Cannot_Save}');
                }
            });          
        }

        function SaveCleaningBelt(e, showerID)
        {                            
            if (e != null && showerID.length > 0)
            {
                Visualforce.remoting.Manager.invokeAction
                (
                    '{!$RemoteAction.MachineSectionMapController.UpdateEditCleaningBelt}',
                    showerID,
                    e.value,
                    function(result, event)
                    {
                        console.log("Updated Cleaning Belt selection!");
                    }
                );                                
            }
            return true;
        }

        function UpdateMetadataValue(e)
        {                            
            var att = e != null && e.attributes != null ? e.attributes['data-key'] : null;
            if (att != null)
            {                                
                var nodeKey = att.value;                                
                if (nodeKey)
                {
                    var node = diagram.findNodeForKey(nodeKey);                                     
                    var meta = metadata[node.data.recordType];  
                    //console.log('Inside UpdateMetadataValue, node = ' + node + ', meta = ' + meta);                                  
                    var metadataDef = null;

                    for (var i = 0; i < meta.length && metadataDef == null; i++)
                    {
                        if (meta[i].path == e.id)
                            metadataDef = meta[i];
                    }

                    var vals = metadataVals[nodeKey];
                    if (vals == null)
                    {
                        vals = new Object();
                        metadataVals[nodeKey] = vals;
                    }

                    if (metadataDef.isNumber)
                    {
                        if (e.value.length > 0)
                        {
                            if (!j$.isNumeric(e.value))
                            {
                                alert (metadataDef.label + ": {!$Label.Numbers_Only}");
                                //console.log('Inside UpdateMetadataValue function!!');

                                e.value = null;
                                return false;
                            }
                        }
                    }

                    if (metadataDef.isCheckbox)
                    {
                        vals[e.id] = e.checked ? "true" : "false";
                    }
                    else
                    {
                        vals[e.id] = e.value;
                    }

                    if (!loading)
                    {
                        node.data.dirty = true;
                        updateDirty();
                    }

                    if (!updatingMetadata)
                    {
                        HandleSpecialCases(node, e.id, e.value);
                    }
                }
            }
            return true;
        }

        function HandleSpecialCases(node, prop, val)
        {
            var config = GetConfig(node.data.recordType);
            if (config != null && config.Label_Editable__c && prop == config.Label_Field__c)
            {
                if (node.category == "roll")
                {
                    // special-special case roll for rotary joint positioning
                    UpdateRollLabel(node, val);
                }
                else
                {
                    var tb = node.findObject("LABEL");
                    if (tb != null)
                        tb.text = val;
                }
            }

            switch (node.category)
            {
                case "roll":
                {
                    switch (prop)
                    {
                        case "Belt_Relationship__c":
                        {
                            if (val != PICKLIST_UNSET)
                            {
                                diagram.startTransaction("change belt side");

                                if (val == "Spare")
                                {
                                    MakeSpare (node);
                                }
                                else
                                {
                                    var inside = val == "Inside";

                                    node.data.outside = !inside;
                                }

                                diagram.commitTransaction("change belt side");

                                UpdateAllBelts();
                            }
                            break;
                        }
                    }
                    break;
                }
            }
        }

        function UpdateRollLabelFromKey (k)
        {
            var roll = diagram.findNodeForKey(k);
            if (roll)
                UpdateRollFindLabel (roll);
        }

        function UpdateRollFindLabel (roll)
        {
            if (roll.data)
            {
                var vals = metadataVals[roll.data.key];

                if (vals)
                {
                    var config = GetConfig(roll.data.recordType);

                    var fieldName = config == null || config.Label_Field__c == null ? "Label__c" : config.Label_Field__c;

                    var label = vals[fieldName];

                    UpdateRollLabel (roll, label);
                }
            }
        }

        function UpdateRollLabel (roll, label)
        {
            var rollKey = roll.data.key;
            var yOffset = 0;
            var skip = false;

            diagram.startTransaction("set roll label");

            for (var it = diagram.nodes.iterator; it.next() ; )
            {
                var node = it.value;
                var d = node.data;

                if (d && d.snappedTo == rollKey && d.objectType == "Rotary Joint")
                {
                    skip = d.inPalette;

                    yOffset = (node.measuredBounds.height * node.scale) - 1;
                    //console.log ("node scale = " + node.scale + ", skip = " + skip + ", h = " + node.measuredBounds.height);
                    break;
                }
            }

            //console.log ("roll " + rollKey + " label to " + label + ", offset " + yOffset);

            if (!skip)
            {
                var tb = roll.findObject("LABEL");
                if (tb != null)
                {
                    tb.text = label;
                    tb.alignment = new go.Spot (0.5, 0.5, 0, yOffset);
                }
            }

            diagram.commitTransaction("set roll label");
        }

        function ResetMetadataPanel()
        {
            j$('#metadataGroup').empty();
            j$('#searchModal').empty();                            
            var indexDescField = 0;
            var indexCustField = 0;
            var indexPartField = 0;
            var indexItemField = 0;
            partFieldPartOptions = '';
            partFieldPartOptions = "<option value='" + PICKLIST_UNSET + "'></option>";
            partFieldDescOptions = '';
            partFieldDescOptions =  "<option value='" + PICKLIST_UNSET + "'></option>";
            partFieldCustOptions = '';
            partFieldCustOptions =  "<option value='" + PICKLIST_UNSET + "'></option>";
            var node = diagram.selection.first();              

            var newText = '';

            if (node && node instanceof go.Node && !node.data.isGroup && node.data.recordType)
            {
                var rt = node.data.recordType;
                var ot = node.data.objectType;
                var sot = node.data.sObjectType;
                var objId = node.data.objectId;
                var meta = metadata[rt];
                var config = GetConfig(rt);

                var label = node.findObject("LABEL");
                //var clicky;
                //clicky = ' onclick="NavigateTo(\'/' + node.data.objectId + '\');"';
                newText += "<div style='width:100%;'>";
                //newText += "<h3 id='metadataHeader'" + clicky + " style='cursor: pointer;'>&nbsp;" + ot + ": " + rt + "</h3>";
                var theHost = window.location.hostname;
                newText += ot + ": " + rt + "&nbsp;:&nbsp;<a href='https://" + theHost + "/lightning/r/" + sot + "/" + objId + "/view' target='_blank'>Equipment Home Page</a>";
                newText += "&nbsp;:&nbsp;<a href='https://" + theHost + "/apex/ServiceReportEquipmentItems?id=" + objId + "' target='_blank'>Equipment Report History</a>";
                newText += "<br/>";
                newText += "<table id='metadataTable'>";

                // Add Part Search to the top of the Metadata Panel
                newText += "<tr><td class='colLabel'></td>";
                newText += "<td style='vertical-align: top;'><a href='#searchModal'><img src='/img/func_icons/util/search16.png' alt='Part Search'>&nbsp;Part Search</a></td></tr>";

                for (var i = 0; meta != null && i < meta.length; i++)
                {
                    newText += "<tr>";
                    var label;
                    var val;
                    var m = meta[i];
                    var lstuff = "for='" + m.path + "'>" + m.label + "&nbsp;";

                    var stuff =
                        " id='" + m.path + "'" +
                        " onchange='UpdateMetadataValue(this);'" +
                        " onfocus='StillActive();'" +
                        " data-key='" + node.data.key + "'";

                    if (m.isReadOnly || {!IsReadOnly})
                        stuff += " disabled='disabled'";

                    var req = m.isRequired ? "<div class='requiredBlock'></div>" : "";
                    var labelClass = 'colLabel';

                    if (m.isCheckbox)
                    {
                        label = "<label " + lstuff + "</label>";
                        val = "<td class='colValue'><div class='requiredInput'>" + req + "<input " + stuff + " type='checkbox' /></div></td>";
                    }
                    else if (m.isDate)
                    {
                        label = "<label " + lstuff + "</label>";
                        val = "<td class='colValue'><div class='requiredInput'>" + req + "<input " + stuff + " type='date' /></div></td>";
                    }
                    else if (m.picks && m.picks.length > 0)
                    {
                        label = "<label " + lstuff + "</label>";
                        val = "<td class='colValue'><div class='requiredInput'>" + req + "<select " + stuff + ">";
                        val += "<option " + (m.defaultVal == "" ? "selected " : "") +
                            "value='" + PICKLIST_UNSET +
                            "'>{!$Label.Picklist_Unset}</option>";

                        for (var x = 0; x < m.picks.length; x++)
                        {
                            var pick = m.picks[x];
                            var sel = m.defaultVal == pick.value ? "selected " : "";
                            val += "<option " + sel + "value='" + pick.value + "'>" + pick.label + "</option>";
                        }

                        val += "</select></div></td>";
                    }
                    else if (m.visibleLines != 1)
                    {
                        labelClass = 'colLabelTop';
                        label = "<label " + lstuff + "</label>";
                        val = "<td class='colValue'><div class='requiredInput'>" + req +
                            "<textarea rows='" + m.visibleLines + "' " + stuff + " maxlength='" + m.maxLen + "' /></div></td>";
                    }
                    else
                    {
                        // Text field:
                        if (m.label.indexOf('Drawing') > 0)
                        {
                            lstuff = '';
                            lstuff = "for='" + m.path + "'><a href=\"#\" onclick=\"getDrawing('" + m.path + "'); return false;\">" + m.label + "</a>&nbsp;";
                        }
                        label = "<label " + lstuff + "</label>";
                        val = "<td class='colValue'><div class='requiredInput'>" + req + "<input " + stuff + " type='text' maxlength='" + m.maxLen + "' /></div></td>";
                        indexDescField = m.label.indexOf('Description');
                        indexCustField = m.label.indexOf('Customer Item Number');
                        indexPartField = m.label.indexOf('Kadant Item Number');
                        indexItemField = m.label.indexOf('Part Number');

                        if (indexDescField > 0)
                        {
                            partFieldDescOptions += "<option value='" + m.path + "'>" + m.label + "</option>";
                        }
                        else if (indexCustField > 0)
                        {
                            partFieldCustOptions += "<option value='" + m.path + "'>" + m.label + "</option>";
                        }
                        else if ((indexPartField > 0) || (indexItemField > 0))
                        {
                            partFieldPartOptions += "<option value='" + m.path + "'>" + m.label + "</option>";
                        }
                        else
                        {
                            indexDescField = 0;
                            indexCustField = 0;
                            indexPartField = 0;
                            indexItemField = 0;
                        }
                    }

                    if (m.helpText != null && m.helpText != "")
                    {
                        newText += "<td class='" + labelClass + "'>";
                        newText += "<span class='helpButton'>";
                        newText += label;
                        newText += "<img src='/s.gif' title=\"" + m.helpText + "\" class='helpOrb'/>"
                        newText += "</td>";
                    }
                    else
                    {
                        newText += "<td class='" + labelClass + "'>" + label + "</td>";
                    }

                    newText += val;
                    newText += "</tr>";
                }

                if (ot == "Cleaning")
                {
                    var showerId = node.data.objectId;

                    // Cleaning drop down for selecting a belt
                    newText += "<tr><td class='colLabel'>Select Belt</td><td>";
                    newText += "<select id='Belt__c' onchange=\"SaveCleaningBelt(this, '" + showerId + "');\" onfocus='StillActive();'>";
                    newText += "<option value=''>No Belt Selected</option>";

                    // Get all of the possible BELT values for this Section Map
                    sforce.connection.sessionId = '{!$Api.Session_ID}';
                    var sqlStr = "Select Id, Postion__c FROM Machine_Mapping_Belt__c WHERE Machine_Section__c = '{!MachineSectionId}' AND IsDeleted = false AND Postion__c != NULL AND Postion__c != ''";
                    var sqlResult = sforce.connection.query(sqlStr);
                    var sectionBelts = sqlResult.getArray('records');                                    

                    if (sectionBelts && sectionBelts.length && showerId)
                    {
                        // Now go get this Cleaning item and see if the Belt has a value and if so select it in the drop-down
                        sqlStr = "Select Id, Belt__c, Nozzle_Code__c, Nozzle_Quantity__c, Nozzle_Spacing__c, Nozzle_Fan_Angle__c, Distance_to_Fabric_Roll__c FROM Machine_Mapping_Cleaning__c WHERE Id = '" + showerId + "'";
                        var sqlShower = sforce.connection.query(sqlStr);
                        var showerResult = sqlShower.getArray('records');

                        var beltId = showerResult[0].Belt__c;
                        var ncode = showerResult[0].Nozzle_Code__c;
                        var nqty = showerResult[0].Nozzle_Quantity__c;
                        var nspace = showerResult[0].Nozzle_Spacing__c;
                        var nangle = showerResult[0].Nozzle_Fan_Angle__c;
                        var ndist = showerResult[0].Distance_to_Fabric_Roll__c;

                        for (var i = 0; i < sectionBelts.length; i++)
                        {
                            // Additional check for blank description; shouldn't happen!!
                            if (sectionBelts[i].Postion__c)
                            {
                                if (beltId == sectionBelts[i].Id)
                                {
                                    newText += "<option value='" + sectionBelts[i].Id + "' selected>" + sectionBelts[i].Postion__c + "</option>";
                                }
                                else
                                {
                                    newText += "<option value='" + sectionBelts[i].Id + "'>" + sectionBelts[i].Postion__c + "</option>";
                                }
                            }
                        }
                    }
                    newText += "</td></tr>";
                    // check for Fan Shower, Double or Purge to display the Shower Coverage Calculator
                    if ((rt === "Fan Shower") || (rt === "Double-Tube Fan Shower") || (rt === "Purge-Fan"))
                    {
                        newText += "<tr><td class='colLabel'>Shower Coverage</td><td><a href=\"#\" onclick=\"calculatePopUp('" + showerId + "'); return false;\">Calculate</a>";
                        newText += "&nbsp;&nbsp;&nbsp;&nbsp;";
                        //assignCoverageValues(noz_code, noz_qty, noz_space, noz_ang, noz_height, showerID)
                        newText += "<a href=\"#\" onclick=\"assignCoverageValues('" + ncode + "','" + nqty + "','" + nspace + "','" + nangle + "','" + ndist + "','" + showerId + "');";
                        newText += " return false;\">Assign Shower Coverage</a></td></tr>";
                    }
                }

                newText += "</table>";
                newText += "</div>";

                if (rt == "Belt")
                {
                    // Determine if this is a SheetPath Belt?!?
                    isSheetPath = false;
                    //var showerId = node.data.objectId;
                }

                if ({!DragDropEnabled})
                {
                    newText += "<hr/>";
                    newText += "<div>";

                    if ({!IsReadOnly} == false)
                    {
                        newText += "<div id='attachment-help-div'><p id='attachment-help'>{!$Label.Drag_Drop_Instructions}</p></div>";

                        newText += "<div id='drag-drop-top'>";
                        newText += "<div id='attachment-drag-box'>";
                        newText +=  "<div id='attachment-inner' class='drag-not-active' >";
                        newText +=   "<input onchange='DropAttachments(event);' type='file' name='files[]' id='select-attachments' data-multiple-caption='{count} files selected' multiple />";
                        newText +=  "</div>";
                        newText += "</div>";
                        newText += "</br>";

                        newText += "<div id='upload-div'>";
                        newText += "<table id='upload-table'>";
                        newText += "</table>";
                        newText += "</div>";
                    }

                    newText += "<div id='attachmentsDiv'><div><table id='attachmentsTable'>";
                    newText += "</table></div></div>";
                    newText += "</div>";
                }

                j$('#metadataGroup').append(newText);

                if ({!DragDropEnabled})
                {                                    
                    //console.log("Inside DragDropEnabled in ResetMetadata = isSheetPath - " + isSheetPath);
                    if ({!IsReadOnly} == false)
                    {
                        j$("#drag-drop-top").on('drag dragstart dragend dragover dragenter dragleave drop', function(e)
                        {
                            e.preventDefault();
                            e.stopPropagation();
                        })
                        .on('dragover dragenter', function()
                        {
                            j$("#attachment-inner").addClass('drag-active');
                        })
                        .on('dragleave dragend drop', function()
                        {
                            j$("#attachment-inner").removeClass('drag-active');
                        })
                        .on('drop', function(e)
                        {
                            DropAttachments(e.originalEvent);
                        });
                    }

                    if (node.data.objectId)
                    {
                        GetAttachments();
                    }
                }

                // if we have an object id but the metadata is blank, load it from sfdc
                if (node.data.objectId && metadataVals[node.data.key] == null)
                {
                    sforce.connection.sessionId = '{!$Api.Session_ID}';

                    var meta = metadata[rt];

                    if (meta && meta.length > 0)
                    {
                        var fields = [];
                        for (var i = 0; i < meta.length; i++)
                            fields.push (meta[i].path);

                        var ot = node.data.sObjectType;

                        var soql =
                            "SELECT " + fields.join() +
                            " FROM " + node.data.sObjectType +
                            " WHERE Id = '" + node.data.objectId + "'" +
                            " LIMIT 1";

                        var result = sforce.connection.query(soql,
                        {
                            onSuccess : function(results, source)
                            {
                                var record = results.records;

                                SaveMetadataVals(record);
                                ShowMetadataVals(node.data.key, rt);
                            },
                            onFailure : function(error, source)
                            {
                                console.log("An error has occurred: " + error);
                            }
                        });
                    }
                }
                ShowMetadataVals(node.data.key, rt);
                var searchText = LoadPartSearch();
                j$('#searchModal').append(searchText);
            }
            else
            if (node)
            {
                var l = "{!$Label.Metadata_No_Values}";
                if (l != "(empty)")
                    newText += "<h3 id='metadataHeader'>&nbsp;" + l + "</h3>";

                j$('#metadataGroup').append(newText);
            }
            else
            {
                var l = "{!$Label.Metadata_Nothing_Selected}";
                if (l != "(empty)")
                    newText += "<h3 id='metadataHeader'>&nbsp;" + l + "</h3>";

                j$('#metadataGroup').append(newText);
            }
        }

        function DropAttachments(e)
        {
            //console.log("DropAttachments");

            var files;

            if (e.dataTransfer)
            {
                files = e.dataTransfer.files;
            }
            else
            if (e.currentTarget)
            {
                files = e.currentTarget.files;
            }

            var node = diagram.selection.first();
            var partId = node.data.objectId;

            try
            {
                for (var i = 0; files && i < files.length; i++)
                {
                    var file = files[i];

                    //console.log(file);
                    if (file.size <= maxFileSize)
                    {
                        var reader = new FileReader();

                        reader.theFile = file;
                        reader.position = 0;
                        reader.partId = partId;
                        reader.doneUploading = false;
                        reader.index = i + uploadIndex++;

                        var hadError = false;

                        reader.onloadend = function(e)
                        {
                            this.attachment = btoa(this.result);
                            this.fileSize = this.attachment.length;

                            var row = "";
                            row += "<tr id='upload-row_" + this.index + "'>";
                            row +=  "<td>" + this.theFile.name + "</td>";
                            row +=  "<td><progress value='0' max='" + this.fileSize + "' id='upload-progress_" + this.index + "'></td>";
                            row += "</tr>";

                            //console.log("row " + this.index + ": " + row);

                            j$("#upload-table").append(row);

                            //console.log("Total Attachment Length: " + this.fileSize);

                            if (this.fileSize < maxStringSize)
                            {
                                UploadAttachment(null, this);
                            }
                            else
                            {
                                alert(this.theFile.name + " : {!$Label.Drag_Drop_Too_Big}");
                                hadError = true;
                            }
                        }

                        reader.onerror = function(e)
                        {
                            alert(this.theFile.name + " : {!$Label.Drag_Drop_Generic_Error}");
                        }
                        reader.onabort = function(e)
                        {
                            alert(this.theFile.name + " : {!$Label.Drag_Drop_Generic_Error}");
                        }

                        if (!hadError)
                        {
                            reader.readAsBinaryString(file);
                        }
                    }
                    else
                    {
                        alert(file.name + " : {!$Label.Drag_Drop_Too_Big}");
                    }
                }
            }
            catch (ex)
            {
                console.log("exception on upload loop: " + ex);
            }
        }

        function UploadAttachment(fileId, reader)
        {
            var body = "";
            if (reader.fileSize <= reader.position + chunkSize)
            {
                // last chunk or we read it all in one
                body = reader.attachment.substring(reader.position);
                reader.doneUploading = true;
            }
            else
            {
                // next chunk.. there will be more after this
                body = reader.attachment.substring(reader.position, reader.position + chunkSize);
            }

            //console.log("Uploading " + body.length + " chars of " + reader.fileSize);

            MachineSectionMapController.UploadFile
            (
                reader.partId, fileId, reader.theFile.name, body,
                function(result, event)
                {
                    //console.log(result);

                    if (event.type === 'exception')
                    {
                        //console.log("exception");
                        //console.log(event);
                    }
                    else
                    if (event.status)
                    {
                        var ret = JSON.parse(result);

                        if (reader.doneUploading == true)
                        {
                            //console.log("row " + reader.index + " done");
                            j$("#upload-row_" + reader.index).remove();

                            var rows = j$('#upload-table tr').length;
                            if (rows < 1)
                            {
                                GetAttachments(); // refresh
                            }
                        }
                        else
                        {
                            reader.position += chunkSize;

                            //console.log('upload row ' + reader.index + ' to ' + reader.position);

                            j$("#upload-progress_" + reader.index).attr("value", reader.position);
                            UploadAttachment(ret.cv, reader);
                        }
                    }
                    else
                    {
                        //console.log(event.message);
                    }
                },
                {buffer: true, escape: false, timeout: 120000}
            );
        }

        function log(title, stuff)
        {
            log(title, stuff, false);
        }

        var logging = true;
        function log(title, stuff, force) // recursive...
        {
            if (force || logging)
            {
                if (stuff && stuff instanceof Array)
                {
                    for (var i = 0; i < stuff.length; i++)
                        log (title + '[' + i + ']', stuff[i], force);
                }
                else
                if (typeof stuff === 'object')
                {
                    for (var prop in stuff)
                        log (title + '.' + prop, stuff[prop], force);
                }
                else
                {
                    //console.log (title + ' = ' + stuff);
                }
            }
        }


        function ParseGetAttachments(result, event)
        {
            //console.log(result);
            if (event.status) // success
            {
                j$("#attachmentsTable").empty();

                var docs = JSON.parse(result);

                var tab = "";

                if (docs.length > 0)
                {
                    tab +=
                        "<thead><tr>" +
                            "<th>Action</th>" +
                            "<th>File</th>" +
                            "<th>Type</th>" +
                            "<th>Size</th>" +
                            "<th>Modified By</th>" +
                            "<th>Modified On</th>" +
                            "</tr></thead>" +
                            "</tbody>";
                }

                for (var i = 0; i < docs.length; i++)
                {
                    var f = docs[i];

                    var raw = new Date(f.ContentModifiedDate);
                    var modDate = raw.toDateString().substring(3);

                    var sizeStr;
                    var size = f.ContentSize;

                    if (size > 2 ** 30)
                        sizeStr = (size / (2 ** 30)).toFixed(1) + " GB";
                    else
                    if (size > 2 ** 20)
                        sizeStr = (size / (2 ** 20)).toFixed(1) + " MB";
                    else
                    if (size > 2 ** 10)
                        sizeStr = (size / (2 ** 10)).toFixed(1) + " KB";
                    else
                        sizeStr = size + " bytes";

                    var title = f.Title.replace(/-/g, " ");

                    var del = "";
                    if ({!IsReadOnly} == false)
                    {
                        del = " | <a data-id='" + f.Id + "' onclick='DeleteAttachment(event);'>Delete</a>";
                    }

                    tab +=
                        "<tr>" +
                            "<td class='centered'><a data-id='" + f.Id + "' onclick='ViewAttachment(event);'>View</a>" + del + "</td>" +
                            "<td class='wrapped'>" + title + "</td>" +
                            "<td>" + f.FileType + "</td>" +
                            "<td>" + sizeStr + "</td>" +
                            "<td>" + f.ContentModifiedBy.Alias + "</td>" +
                            "<td>" + modDate + "</td>" +
                        "</tr>";
                }

                tab += "</tbody>";

                j$("#attachmentsTable").append(tab);
            }
        }

        function GetAttachments()
        {
            var node = diagram.selection.first();
            if (node && node.data && node.data.objectId)
            {
                sforce.connection.sessionId = "{!$Api.Session_ID}";

                Visualforce.remoting.Manager.invokeAction
                (
                    '{!$RemoteAction.MachineSectionMapController.GetAttachments}',
                    node.data.objectId,
                    ParseGetAttachments,
                    {escape: false}
                );
            }
        }

        function DeleteAttachment(e)
        {
            //console.log("DeleteAttachment");

            var node = diagram.selection.first();

            if (confirm("Are you sure you want to delete this file?"))
            {
                Visualforce.remoting.Manager.invokeAction
                (
                    '{!$RemoteAction.MachineSectionMapController.DeleteAttachment}',
                    e.currentTarget.dataset.id,
                    GetAttachments,
                    {escape: false}
                );
            }
        }

        function ViewAttachment(e)
        {
            //console.log("ViewAttachment");

            window.open("{!FileOpenPrefix}" + e.currentTarget.dataset.id, "_blank");
        }

        function ShowMetadataVals (key, rt)
        {
            var vals = metadataVals[key];
            if (vals)
            {
                var meta = metadata[rt];

                for (var val in vals)
                {
                    var prev = j$('#' + val);
                    if (prev != null && prev.length != 0)
                    {
                        if (prev[0].type == "checkbox")
                            j$('#' + val).prop("checked", vals[val] == "true");
                        else
                            j$('#' + val).val(vals[val]);
                    }
                    else
                    {
                        var i = 0;// debug break;
                    }
                }
            }
        }

        function InitTypes()
        {
            recordTypes = new Object();

            // record type (escaped) key to record type id
            <apex:repeat value="{!PaletteGroupKeys}" var="pg">
                palettePrefNames.push("{!pg}");
                <apex:repeat value="{!PaletteEntries[pg]}" var="pe">
                    recordTypes["{!pe.RecTypeLabel}"] = "{!pe.RecTypeId}";
                </apex:repeat>
            </apex:repeat>
            palettePrefNames.push("Notes");
            <apex:repeat value="{!ResourceNames}" var="t">
                imageInfos["{!t}"] = {mime: "{!KeyToMime[t]}", data: "{!KeyToBase64[t]}"};
            </apex:repeat>
        }


        function InitDocImages()
        {
            docImages = new Object();

            <apex:repeat value="{!DoctorTypes}" var="d">
                docImages["{!d}"] = "{!$Resource[KeyToIconR[d]]}";
            </apex:repeat>
        }

        function SnapDistanceForNode(node)
        {
            var name = node.category == "placeholder" || node.category == "roll" ? "Roll" : node.data.name;

            var config = GetConfig(name);

            return config.Snap_Distance__c;
        }

        function InitPrefs()
        {
            userPrefs = new Object();

            <apex:repeat value="{!UserPreferences}" var="pref">
                userPrefs["{!pref}"] = "{!UserPreferences[pref]}";
            </apex:repeat>
        }

        function UpdatePreference(prefName, newVal)
        {
            Visualforce.remoting.Manager.invokeAction
            (
                '{!$RemoteAction.MachineSectionMapController.UpdatePreference}', prefName, newVal,
                function(result, event)
                {
                    if (event.status && result == null) // call success
                    {
                    }
                    else
                    {
                        var msg = "Unable to set preference"; // todo: label?
                        if (event.message && event.message !== "")
                        {
                            msg += "\n\n" + event.message;
                        }

                        alert (msg);
                    }
                },
                {escape: false}
            );
        }

        function InitConfigs()
        {
            configs = new Object();

            var config;

            <apex:repeat value="{!MachinePartConfigs}" var="jsonStr">
                var config = JSON.parse('{!jsonStr}');

                configs[config.Record_Type__c] = config;
            </apex:repeat>

            var def = configs["(default)"];

            // force nulls to bools on checkbox defaults
            def.Allow_Link_From__c = IsCheckboxSet(def.Allow_Link_From__c);
            def.Allow_Link_To__c   = IsCheckboxSet(def.Allow_Link_To__c);
            def.Label_Editable__c  = IsCheckboxSet(def.Label_Editable__c);
            def.Label_Multiline__c = IsCheckboxSet(def.Label_Multiline__c);

            for (rt in configs)
            {
                if (rt == "(default)")
                    continue;

                config = configs[rt];

                if (IsCheckboxSet(config.Link_Use_Defaults__c))
                {
                    config.Allow_Link_To__c = def.Allow_Link_To__c;
                    config.Allow_Link_From__c = def.Allow_Link_From__c;
                }
                else
                {
                    config.Allow_Link_From__c = IsCheckboxSet(config.Allow_Link_From__c);
                    config.Allow_Link_To__c   = IsCheckboxSet(config.Allow_Link_To__c);
                }

                if (IsCheckboxSet(config.Label_Use_Defaults__c))
                {
                    config.Label_Editable__c  = def.Label_Editable__c;
                    config.Label_Multiline__c = def.Label_Multiline__c;
                }
                else
                {
                    config.Label_Editable__c  = IsCheckboxSet(config.Label_Editable__c);
                    config.Label_Multiline__c = IsCheckboxSet(config.Label_Multiline__c);
                }

                if (config.Canvas_Scale__c == null)
                    config.Canvas_Scale__c = def.Canvas_Scale__c;

                if (config.Doctor_Offset_X__c == null)
                    config.Doctor_Offset_X__c = def.Doctor_Offset_X__c;

                if (config.Doctor_Offset_Y__c == null)
                    config.Doctor_Offset_Y__c = def.Doctor_Offset_Y__c;

                if (config.Label_Color__c == null)
                    config.Label_Color__c = def.Label_Color__c;

                if (config.Label_Offset_X__c == null)
                    config.Label_Offset_X__c = def.Label_Offset_X__c;

                if (config.Label_Offset_Y__c == null)
                    config.Label_Offset_Y__c = def.Label_Offset_Y__c;

                if (config.Palette_Scale__c == null)
                    config.Palette_Scale__c = def.Palette_Scale__c;

                if (config.Snap_Distance__c == null)
                    config.Snap_Distance__c = def.Snap_Distance__c;
            }
        }

        function GetConfig(recType)
        {
            var ret = configs[recType];
            if (ret == null)
                ret = GetDefaultConfig();

            return ret;
        }

        function GetDefaultConfig()
        {
            return configs["(default)"];
        }

        function GetScale(rt)
        {
            var config = GetConfig(rt);

            return config.Canvas_Scale__c;
        }

        function GetPaletteScale(rt)
        {
            var config = GetConfig(rt);

            return config.Palette_Scale__c;
        }

        function InitMetadata()
        {
            metadata = new Object();

            var meta;
            var fVals;

            sforce.connection.sessionId = '{!$Api.Session_ID}';
            var l;

            var recTypePicks = new Object();

            <apex:repeat value="{!PartObjectTypeNames}" var="s">
                l = sforce.connection.describeLayout("{!s}");

                for (var i = 0; i < l.recordTypeMappings.length; i++)
                {
                    var rtm = l.recordTypeMappings[i];
                    if (rtm.picklistsForRecordType && rtm.name != "Master")
                    {
                        for (var j = 0; j < rtm.picklistsForRecordType.length; j++)
                        {
                            var pvs = rtm.picklistsForRecordType[j];

                            var key = rtm.name + '.' + pvs.picklistName;

                            recTypePicks[key] = pvs;
                        }
                    }
                }
            </apex:repeat>



            <apex:repeat value="{!MetadataTypes}" var="fields">
                //console.log ('outer type {!fields}');

                fVals = [];

                <apex:repeat value="{!Metadata[fields]}" var="finfo">
                    //console.log ('inner type {!finfo}');

                    meta =
                    {
                        label: "{!finfo.Label}",
                        path: "{!finfo.FieldPath}",
                        isNumber: {!finfo.IsNumber},
                        isDate: {!finfo.IsDate},
                        isCheckbox: {!finfo.IsCheckbox},
                        isReadOnly: {!finfo.IsReadOnly},
                        isRequired: {!finfo.IsRequired},
                        visibleLines: {!finfo.VisibleLines},
                        maxLen: {!finfo.MaxLen},
                        helpText: "{!finfo.HelpText}",
                        defaultVal: "{!finfo.DefaultValue}"
                    };

                    <apex:outputText rendered="{!finfo.IsPicklist = true}">
                        meta.picks = [];

                        var key = "{!fields}.{!finfo.FieldPath}";
                        var rtPicks = recTypePicks[key];
                        if (rtPicks != null)
                        {
                            //console.log ("using RT picklist for " + key);
                            for (var i = 0; i < rtPicks.picklistValues.length; i++)
                            {
                                var pe = rtPicks.picklistValues[i];
                                if (pe.active == "true")
                                {
                                    meta.picks.push({label: pe.label, value: pe.value});

                                    if (pe.defaultValue == "true")
                                    {
                                        meta.defaultVal = pe.value;
                                    }
                                }
                            }
                        }
                        else
                        {
                            <apex:repeat value="{!finfo.Picks}" var="pe">
                                meta.picks.push ({label: '{!pe.Label}', value: '{!pe.Value}'});
                            </apex:repeat>
                        }
                    </apex:outputText>

                    fVals.push (meta);

                </apex:repeat>

                metadata['{!fields}'] = fVals;
            </apex:repeat>
        }

        function SetReadOnly()
        {
            j$('.no-read-only').addClass('ui-state-disabled');

            diagram.allowClipboard = false;
            diagram.allowDelete = false;
            diagram.allowDragOut = false;
            diagram.allowDrop = false;
            diagram.allowGroup = false;
            diagram.allowInsert = false;
            diagram.allowLink = false;
            diagram.allowMove = false;
            diagram.allowRelink = false;
            diagram.allowReshape = false;
            diagram.allowResize = false;
            diagram.allowRotate = false;
            diagram.allowTextEdit = false;
            diagram.allowUndo = false;
            diagram.allowUngroup = false;
        }

        function UpdateGridOption()
        {
            diagram.startTransaction("grid");

            var grid = document.getElementById("grid").checked;

            diagram.grid.visible = grid;

            var snap = document.getElementById("snap").checked;
            if (grid)
            {
                diagram.toolManager.draggingTool.isGridSnapEnabled = snap;
                diagram.toolManager.resizingTool.isGridSnapEnabled = snap;
            }
            else
            {
                diagram.toolManager.draggingTool.isGridSnapEnabled = false;
                diagram.toolManager.resizingTool.isGridSnapEnabled = false;
            }

            if (!loading)
            {
                UpdatePreference(PREF_GRID, (grid + "|" + snap));
            }

            diagram.commitTransaction("grid");
        }

        function CloseMenu()
        {
            j$("#menu")
                .menu("blur")
                .menu("collapseAll");
        }

        function OnSelectionChanged(e)
        {
            var node = diagram.selection.first();

            if (node && node.category == "dynamicLine")
            {
                diagram.toolManager.linkingTool.isUnconnectedLinkValid = true;
                diagram.toolManager.relinkingTool.isUnconnectedLinkValid = true;
                diagram.toolManager.relinkingTool.portGravity = 0;
                diagram.toolManager.draggingTool.dragsLink = true;

                dynamicLineSelected = true;

                var s = node.findObject("SHAPE");
                var a = node.findObject("ARROWS");

                //console.log("break");


            }
            else
            if (dynamicLineSelected)
            {
                diagram.toolManager.linkingTool.isUnconnectedLinkValid = false;
                diagram.toolManager.relinkingTool.isUnconnectedLinkValid = false;
                diagram.toolManager.relinkingTool.portGravity = 100;
                diagram.toolManager.draggingTool.dragsLink = false;

                dynamicLineSelected = false;
            }

            if (debug != 0)
            {
                var shape;
                if (node)
                    shape = node.findObject("SHAPE");

                //console.log ("break here");
            }

            CloseMenu();
            ResetMetadataPanel();
        }

        function ClearAll()
        {
            diagram.startTransaction("clear all");

            diagram.commandHandler.selectAll();
            diagram.commandHandler.deleteSelection();

            diagram.commitTransaction("clear all");
        }

        function FlipH()
        {
            diagram.selection.each(function (node)
            {
                var pic = node.findObject('SHAPE');
                if (pic)
                {
                    switch (pic.flip)
                    {
                        case go.GraphObject.None:
                            pic.flip = go.GraphObject.FlipHorizontal;
                            break;

                        case go.GraphObject.FlipHorizontal:
                            pic.flip = go.GraphObject.None;
                            break;

                        case go.GraphObject.FlipVertical:
                            pic.flip = go.GraphObject.FlipBoth;
                            break;

                        case go.GraphObject.FlipBoth:
                            pic.flip = go.GraphObject.FlipVertical;
                            break;
                    }

                    if (node.data && node.data.snappedTo != null)
                        SnapToKey (node, node.data.snappedTo);
                }
            });
        }

        function FlipV()
        {
            diagram.selection.each(function (node)
            {
                var pic = node.findObject('SHAPE');
                if (pic)
                {
                    switch (pic.flip)
                    {
                        case go.GraphObject.None:
                            pic.flip = go.GraphObject.FlipVertical;
                            break;

                        case go.GraphObject.FlipHorizontal:
                            pic.flip = go.GraphObject.FlipBoth;
                            break;

                        case go.GraphObject.FlipVertical:
                            pic.flip = go.GraphObject.None;
                            break;

                        case go.GraphObject.FlipBoth:
                            pic.flip = go.GraphObject.FlipHorizontal;
                            break;
                    }

                    if (node.data && node.data.snappedTo != null)
                        SnapToKey (node, node.data.snappedTo);
                }
            });
        }

        function NewPart(node)
        {
            //console.log ('new part on ' + node);
            //if (node.data)
                //console.log ("new part key: " + node.data.key);

            // be careful to clear out things like the sfdc id and what we're snapped to
            // but leave other stuff. for metadata, if a value is not set but has a default,
            // this is where we want to apply that default
            var d = node.data;
            var k = d.key;

            if (d.recordType)
            {
                d.objectId = null;
                d.snappedTo = null;
                d.snapChange = false;
                d.dirty = true;

                var vals = metadataVals[k];
                if (vals == null)
                {
                    vals = new Object();
                    metadataVals[k] = vals;
                }

                var defs = metadata[d.recordType];

                for (var i = 0; i < defs.length; i++)
                {
                    var def = defs[i];

                    if (def.defaultVal && def.defaultVal != "" && vals[def.path] == null)
                    {
                        //console.log ('need to set default for ' + def.path + ' to ' + def.defaultVal);
                        vals[def.path] = def.defaultVal;
                    }
                }
            }

            updateDirty();
        }

        function FixUpNode(node)
        {
            // called on things like drop and paste, to add a new node to the
            // diagram.. hide the caption, make sure we're not carrying over a
            // object id and set .dirty
            var tb = node.findObject("PALETTE_LABEL");
            if (tb != null)
            {
                if (tb.visible)
                {
                    // only visible on initial drop (or paste?)
                    tb.visible = false;
                }
            }

            var pic = node.findObject('SHAPE');
            if (pic != null)
            {
                pic.scale = GetScale(node.data.recordType);
                //console.log("set scale to " + pic.scale);
            }

            node.data.objectId = '';
            node.data.dirty = true;
            node.data.inPalette = false;

            SetLinkAllowed(node);
            FixLabel(node);

            updateDirty();
        }

        function FixLabel(node)
        {
            switch (node.category)
            {
                case "belt":
                case "placeholder":
                case "group":
                {
                    break;
                }

                case "roll":
                {
                    // allow config to set just single/multiline and color on rolls
                    var label = node.findObject("LABEL");
                    if (label != null)
                    {
                        if (node.data != null && node.data.recordType != null)
                        {
                            var config = GetConfig(node.data.recordType);

                            label.isMultiline = config.Label_Multiline__c;
                            label.stroke = config.Label_Color__c;
                        }
                    }

                    break;
                }

                default:
                {
                    var label = node.findObject("LABEL");
                    if (label != null)
                    {
                        if (node.data != null && node.data.recordType != null)
                        {
                            var config = GetConfig(node.data.recordType);

                            label.editable = config.Label_Editable__c;
                            label.isMultiline = config.Label_Multiline__c;
                            label.stroke = config.Label_Color__c;

                            if ({!DebugLabelPosition} && label.editable && (label.text == null || label.text.trim() == ""))
                            {
                                label.background = "#808080";
                                label.text = " ";
                            }

                            var pos = new go.Spot();
                            pos.offsetX = config.Label_Offset_X__c;
                            pos.offsetY = config.Label_Offset_Y__c;

                            label.alignment = pos;
                            label.angle = -node.angle;
                        }
                    }
                    break;
                }
            }
        }

        function IsCheckboxSet(cb)
        {
            return cb != null && cb == true;
        }

        function SetLinkAllowed(node)
        {
            switch (node.category)
            {
                case "belt":
                case "annotation":
                case "circleNote":
                {
                    break;
                }

                default:
                {
                    var shape = node.findObject("SHAPE");
                    if (shape != null)
                    {
                        var config = GetConfig(node.data.recordType);

                        shape.toLinkable = config.Allow_Link_To__c;
                        shape.fromLinkable = config.Allow_Link_From__c;
                        shape.cursor = "pointer";
                        shape.portId = "";
                    }

                    break;
                }
            }
        }
        
        function HighLightImage (key, show)
        {
            var nodeCat = key.category;
            if (nodeCat == "cleaning")
            {
                var shape = key.findObject("SHAPE");
                if(show)
                {                        
                    shape.scale = 1.05;
                    return;
                }
                shape.scale = GetScale(key.data.recordType);
            }
        }

        function Init()
        {
            //console.log ('init');

            go.licenseKey = "{!LicenseKey}";

            var annotationAssociationLinkTemplate =
                g$(go.Link,
                {
                    reshapable: true,
                    relinkableFrom: true,
                    relinkableTo: true
                },
                new go.Binding("points").makeTwoWay(),
                g$(go.Shape,
                {
                    stroke: "black",
                    strokeWidth: 1,
                    strokeDashArray: [1, 1]
                }),
                g$(go.Shape,
                {
                    toArrow: "",
                    scale: 1,
                    stroke: "black"
                },
                {
                    mouseEnter: function(e, obj, prev)
                    {
                        StillActive();
                    },
                    mouseLeave: function(e, obj, next)
                    {
                        StillActive();
                    }
                })
            );

            var dynamicLineTemplate =
                g$(go.Link,
                {
                    selectionAdorned: false,
                    movable: true,
                    toLinkable: true,
                    fromLinkable: true,
                    reshapable: true,
                    relinkableFrom: true,
                    relinkableTo: true
                },
                new go.Binding("points").makeTwoWay(),
                g$(go.Shape,
                {
                    name: "SHAPE",
                    isPanelMain: true,
                    stroke: "black",
                    strokeWidth: 2
                }),
                g$(go.Shape,
                {
                    name: "ARROWS",
                    toArrow: ARROW_NONE,
                    fromArrow: ARROW_NONE,
                    stroke: null
                },
                new go.Binding("fill").makeTwoWay(),
                new go.Binding("toArrow").makeTwoWay(),
                new go.Binding("fromArrow").makeTwoWay())
            );


            var linkTemplateMap = new go.Map();
            linkTemplateMap.add("annotation", annotationAssociationLinkTemplate);
            linkTemplateMap.add("circleNote", annotationAssociationLinkTemplate);
            linkTemplateMap.add("dynamicLine", dynamicLineTemplate);
            linkTemplateMap.add("", annotationAssociationLinkTemplate);

            diagram = g$(go.Diagram, "diagramDiv",
            {
                allowDrop: true,
                "animationManager.isEnabled": false,
                "undoManager.isEnabled": true,
                "grid.visible": false,
                initialContentAlignment: go.Spot.Center,
                initialAutoScale: go.Diagram.Uniform,
                linkTemplateMap: linkTemplateMap,
                ChangedSelection: OnSelectionChanged,
                "toolManager.mouseWheelBehavior": go.ToolManager.WheelZoom,
                "linkingTool.direction": go.LinkingTool.ForwardsOnly,

                "commandHandler.archetypeGroupData": { isGroup: true, category: "group" },
                "ModelChanged": function(e)
                {
                    if (e.isTransactionFinished)
                    {
                        var saved = document.getElementById("savedModel");
                        if (saved)
                            saved.textContent = diagram.model.toJson();
                    }
                },
                "commandHandler.pasteFromClipboard": function()
                {
                    for (var it = diagram.selection.iterator; it.next() ; )
                    {
                        var node = it.value;
                        if (node.data)
                            node.data.copiedFrom = node.data.key;
                    }

                    return go.CommandHandler.prototype.pasteFromClipboard.call(this); // .base()
                },
                "draggingTool.doDropOnto": function(pt, obj)
                {
                    go.DraggingTool.prototype.doDropOnto.call(this, pt, obj); // .base()

                    for (var it = diagram.selection.iterator; it.next() ;)
                    {
                        node = it.value;
                        if (node.data && node.data.snapping)
                            SetupSnap(node);
                    }
                },
                "draggingTool.moveParts": function(parts, offset, check)
                {
                    go.DraggingTool.prototype.moveParts.call(this, parts, offset, check); // .base()

                    diagramDirty = true;
                    var rolls = new go.Set();
                    var movedPlaceholder = null;
                    var updateBelts = false;
                    var checkAccOnMap = false;

                    for (var it = parts.iterator; it.next() ; )
                    {
                        var node = it.key;
                        if ((node.category == 'belt') && (node.data.recordType == 'Sheet Path'))
                        {
                            isSheetPath = true;
                        }
                        if (node.data.snapToBelt) // it.key.category == "roll")
                        {
                            rolls.add (node.data.key);
                            if (node.data.onBelt != null || node.data.snappedTo != null)
                                updateBelts = true;
                        }
                        else
                        if (node.category == 'resizableArrow' || node.category == 'nonresizableArrow')
                        {
                            FixArrowShape(node);
                        }

                        if (node.category == 'cleaning') {
                            checkAccOnMap = true;
                        }

                        if (node.category == "placeholder" && movedPlaceholder == null) // take 1st one found
                        {
                            if (node.data.onBelt != null)
                                movedPlaceholder = node;
                        }
                    }

                    if (movedPlaceholder != null)
                    {
                        var snapTo = NearestNode(movedPlaceholder, "roll");

                        UnHighlight();
                        if (snapTo != null)
                            Highlight(snapTo.data.key);
                    }

                    if (updateBelts)
                        UpdateAllBelts();

                    if (rolls.size > 0)
                    {
                        for (var it = diagram.nodes.iterator; it.next() ; )
                        {
                            if (it.key.data.snappedTo && rolls.has(it.key.data.snappedTo))
                            {
                                SnapToKey(it.key, it.key.data.snappedTo);
                            }
                        }
                    }
                    else if (checkAccOnMap)
                    {
                        for (var it = diagram.nodes.iterator; it.next() ; )
                        {
                            if (it.key.data.snappedTo)
                            {
                                SnapToKey(it.key, it.key.data.snappedTo);
                            }
                        }
                    }
                    else
                    {
                        var f = parts.first().key;

                        if (f.data && f.data.snapping)
                        {
                            var snapTo = NearestNode (f, f.data.snapTo);
                            if (snapTo != null)
                            {
                                var snapKey = snapTo.data.key;

                                // don't bother re-highlighting if already lit
                                var lit = false;
                                for (var i = 0; i < highlights.length && !lit; i++)
                                    lit |= highlights[i] == snapKey;

                                if (!lit)
                                {
                                    UnHighlight();
                                    Highlight (snapKey);
                                }
                            }
                            else
                            {
                                UnHighlight();
                            }
                        }
                    }
                    updateDirty();
                },
                "resizingTool.resize": function (newR)
                {
                    go.ResizingTool.prototype.resize.call(this, newR); // .base()

                    var updateBelts = false;
                    for (var it = diagram.selection.iterator; it.next() ; )
                    {
                        var node = it.value;

                        if (node.data)
                        {
                            var nodeKey = node.data.key;                                            

                            for (var it = diagram.nodes.iterator; it.next() ; )
                            {
                                if (it.key.data.snappedTo == nodeKey)
                                {
                                    SnapToKey(it.key, nodeKey);
                                }
                            }
                        }

                        if (node.data.onBelt != null)
                            updateBelts = true;
                    }
                    if (updateBelts)
                        UpdateAllBelts();
                },
                "rotatingTool.rotate": function (newAngle)
                {
                    go.RotatingTool.prototype.rotate.call(this, newAngle); // .base()

                    for (var it = diagram.selection.iterator; it.next() ; )
                    {
                        var node = it.value;
                        if (node.data)
                        {
                            node.data.dirty = true;

                            var to = node.data.snappedTo;

                            if (to && node.data.snapping == "outside")
                            {
                                SnapToKey(node, to);
                            }

                            FixLabel(node);
                        }
                    }
                    updateDirty();
                },
                "SelectionDeleted": function(e)
                {
                    UpdateAllBelts();
                }
            });

            diagram.linkTemplate = g$(go.Link, g$(go.Shape));
            diagram.model.linkKeyProperty = "key";

            // separate layer for each palette group
            var forelayer = diagram.findLayer("Foreground");
            <apex:repeat value="{!PaletteGroupKeys}" var="pg">
                diagram.addLayerBefore(g$(go.Layer, { name: "{!pg}" }), forelayer);
            </apex:repeat>

            diagram.addLayerBefore(g$(go.Layer, { name: "Notes" }), forelayer);

            var config = GetDefaultConfig();

            var allowLinkTo = config.Allow_Link_To__c;
            var allowLinkFrom = config.Allow_Link_From__c;

            var templateMap = new go.Map();

            var defaultNodeTemplate =
                g$(go.Node, "Spot",
                    {
                        rotatable: true,
                        locationObjectName: "SHAPE",
                        //toLinkable: true,
                        portId: "",
                        movable: true,
                        locationSpot: go.Spot.Center
                    },
                    new go.Binding("location", "loc", go.Point.parse).makeTwoWay(go.Point.stringify),
                    new go.Binding("angle", "rotate").makeTwoWay(),
                    new go.Binding("scale", "scale").makeTwoWay(),
                    new go.Binding("layerName", "lName"),
                g$(go.Picture,
                    {
                        name: "SHAPE",
                        margin: 5,
                        fromLinkable: allowLinkFrom,
                        toLinkable: allowLinkTo,
                        alignmentFocus: go.Spot.Center
                    },
                    new go.Binding("source"),
                    new go.Binding("scale", "scale").makeTwoWay(),
                    new go.Binding("scale", "imageScale").makeTwoWay(),
                    new go.Binding("flip", "flip").makeTwoWay()
                ),
                g$(go.TextBlock, "",
                    {
                        width: 60,
                        name: "PALETTE_LABEL",
                        font: "{!PaletteFont}",
                        textAlign: "center",
                        wrap: go.TextBlock.WrapFit,
                        alignment: new go.Spot(1.0, 0.5, 35, 0)
                    },
                    new go.Binding("text", "name")
                ),
                g$(go.TextBlock, "",
                    {
                        name: "LABEL",
                        text: " ",
                        textAlign: "center",
                        alignmentFocus: go.Spot.Center
                    },
                    new go.Binding("text").makeTwoWay()
                ),
                {
                    mouseEnter: function(e, obj, prev)
                    {
                        StillActive();
                    },
                    mouseLeave: function(e, obj, next)
                    {
                        StillActive();
                    },
                    mouseDragEnter: function(e, node, prev) 
                    { 
                        HighLightImage(node, true);                                 
                    },
                    mouseDragLeave: function(e, node, next) 
                    { 
                        HighLightImage(node, false); 
                    },
                    mouseDrop: function(e, node)
                    {
                        HighLightImage(node, false); 
                    }
                }
            );

            var rollTemplate =
                g$(go.Node,
                {
                    rotatable: false,
                    locationSpot: go.Spot.Center,
                    locationObjectName: "GUIDE",
                    resizable: true,
                    resizeObjectName: "GUIDE",
                    selectionAdorned: false,
                    //toLinkable: true,
                    fromLinkable: false,
                    movable: true,

                    contextMenu: g$
                    (
                        go.Adornment,
                        "Vertical",
                        g$("ContextMenuButton", g$(go.TextBlock, "{!$Label.Change_Belt_Side}"),
                        {
                            click: function(e, obj)
                            {
                                diagram.startTransaction("change belt side");

                                var contextmenu = obj.part;
                                var nodedata = contextmenu.data;

                                var newVal = !nodedata.outside;

                                nodedata.outside = newVal;
                                diagram.model.setDataProperty(nodedata, "outside", newVal);

                                var rollKey = nodedata.key;

                                for (var it = diagram.nodes.iterator; it.next() ; )
                                {
                                    var node = it.value;
                                    if (node.category == "placeholder" && node.data.snappedTo == rollKey)
                                    {
                                        node.data.outside = !newVal;
                                    }
                                }

                                diagram.commitTransaction("change belt side");

                                UpdateBeltType (newVal ? "Inside" : "Outside");
                                UpdateAllBelts();
                            }
                        },
                        new go.Binding("visible", "", function(o, e)
                        {
                            return o.onBelt != null;
                        })),
                        g$("ContextMenuButton", g$(go.TextBlock, "Debug Label"),
                        {
                            click: function (e, obj)
                            {
                                diagram.startTransaction("debug label");

                                var key = obj.part.data.key;
                                var roll = diagram.findNodeForKey(key);
                                if (roll)
                                {
                                    var tb = roll.findObject("LABEL");
                                    if (tb != null)
                                        tb.text = '' + obj.part.data.key;
                                }

                                diagram.commitTransaction("debug label");
                            }
                        },
                        new go.Binding("visible", "", function(o, e)
                        {
                            return "{!$User.FirstName} {!$User.LastName}" == "Gears CRM";
                        })),
                        g$("ContextMenuButton", g$(go.TextBlock, "Open Tab"),
                        {
                            click: function (e, obj)
                            {
                                diagram.startTransaction("open tab");

                                if (obj && obj.part && obj.part.data && obj.part.data.objectId)
                                {
                                    window.open("/" + obj.part.data.objectId, "_blank");
                                }

                                diagram.commitTransaction("open tab");
                            }
                        },
                        new go.Binding("visible", "", function(o, e)
                        {
                            return "{!$User.FirstName} {!$User.LastName}" == "Gears CRM";
                        })),
                        g$("ContextMenuButton", g$(go.TextBlock, "{!$Label.Menu_Unsnap_From_Belt}"),
                        {
                            click: function (e, obj)
                            {
                                diagram.startTransaction("unsnap from belt");

                                MakeSpare (obj.part);
                                UpdateBeltType("Spare");
                                UpdateAllBelts();

                                diagram.commitTransaction("unsnap from belt");
                            }
                        },
                        new go.Binding("visible", "", function(o, e)
                        {
                            if (o.recordType == "Roll")
                            {
                                var k = o.key;

                                for (var it = diagram.nodes.iterator; it.next() ; )
                                {
                                    var node = it.value;
                                    if (node.category == "placeholder" && node.data.snappedTo == k)
                                        return false;
                                }
                            }

                            return o != null && (o.snappedTo != null || o.onBelt != null);
                        })),

                        g$("ContextMenuButton", g$(go.TextBlock, "{!$Label.Menu_Unsnap_Placeholders}"),
                        {
                            click: function (e, obj)
                            {
                                diagram.startTransaction("unsnap placeholders");

                                var rollKey = obj.part.data.key;

                                var roll = diagram.findNodeForKey(rollKey);

                                var newSize = roll.measuredBounds.width * 0.75;

                                for (var it = diagram.nodes.iterator; it.next() ; )
                                {
                                    var node = it.value;
                                    if (node.category == "placeholder" && node.data.snappedTo == rollKey)
                                    {
                                        node.movable = true;
                                        node.data.snappedTo = null; // still on belt, though

                                        var shape = node.findObject("GUIDE");
                                        shape.visible = true;
                                        shape.strokeDashArray = [6, 3];

                                        shape.width = newSize;
                                        shape.height = newSize;
                                    }
                                }

                                UpdateAllBelts();

                                diagram.commitTransaction("unsnap placeholders");
                            }
                        },
                        new go.Binding("visible", "", function(o, e)
                        {
                            if (o.recordType == "Roll")
                            {
                                var k = o.key;

                                for (var it = diagram.nodes.iterator; it.next() ; )
                                {
                                    var node = it.value;
                                    if (node.category == "placeholder" && node.data.snappedTo == k)
                                        return true;
                                }
                            }

                            return false;
                        })),

                        g$("ContextMenuButton", g$(go.TextBlock, "{!$Label.Menu_Make_Not_Free}"),
                        {
                            click: function (e, obj)
                            {
                                diagram.startTransaction("make not free");

                                obj.part.data.isFreeRoll = false;

                                diagram.commitTransaction("make not free");
                            }
                        },
                        new go.Binding("visible", "", function(o, e)
                        {
                            return o.isFreeRoll == true && node.category == "roll";
                        })),

                        g$("ContextMenuButton", g$(go.TextBlock, "{!$Label.Menu_Make_Free_Roll}"),
                        {
                            click: function(e, obj)
                            {
                                var roll = obj.part;

                                diagram.startTransaction("make free roll");

                                roll.data.isFreeRoll = true;

                                if (roll.data.snappedTo != null)
                                {
                                    MakeSpare (roll);
                                    UpdateBeltType ("Spare");
                                    UpdateAllBelts();
                                }

                                diagram.commitTransaction("make free roll");
                            }
                        },
                        new go.Binding("visible", "", function(o, e)
                        {
                            var k = o.key;

                            for (var it = diagram.nodes.iterator; it.next() ; )
                            {
                                var node = it.value;
                                if (node.category == "placeholder" && node.data.snappedTo == k)
                                    return false;
                            }

                            var node = diagram.findNodeForKey(k);

                            return node.category == "roll" && (o.isFreeRoll == null || o.isFreeRoll == false);
                        }))
                    )
                },
                new go.Binding("location", "loc", go.Point.parse).makeTwoWay(go.Point.stringify),
                new go.Binding("angle", "rotate").makeTwoWay(),
                new go.Binding("scale", "scale").makeTwoWay(),
                new go.Binding("layerName", "lName").makeTwoWay(),
                g$(go.Panel, "Spot",
                    g$(go.Shape, "Circle",
                    {
                        name: "GUIDE",
                        fill: "transparent",
                        width: {!FirstAutoRollSize} * {!RollSizeMultiplier},
                        height: {!FirstAutoRollSize} * {!RollSizeMultiplier},
                        geometryStretch: go.GraphObject.Uniform,
                        strokeWidth: 1
                    },
                    new go.Binding("scale").makeTwoWay(),
                    new go.Binding("scale", "imageScale").makeTwoWay(),
                    new go.Binding("width").makeTwoWay(),
                    new go.Binding("height").makeTwoWay(),
                    new go.Binding("stroke", "isSelected", function(selected, node)
                    {
                        var ret;
                        if (selected)
                            ret = COLOR_SELECTED;
                        else
                        if (node.part && node.part.data.beltError && !node.part.data.isFreeRoll)
                            ret = COLOR_ERROR;
                        else
                            ret = COLOR_NORMAL;

                        return ret;
                    }).ofObject(),
                    new go.Binding("strokeWidth", "isSelected", function(selected, node)
                    {
                        var ret;
                        if (selected)
                            ret = WIDTH_SELECTED;
                        else
                        if (node.part && node.part.data.beltError && !node.part.data.isFreeRoll)
                            ret = WIDTH_ERROR;
                        else
                            ret = WIDTH_NORMAL;

                        return ret;
                    }).ofObject()),

                    g$(go.Panel, "Viewbox",
                        {
                            scale: 0.65
                        },
                        new go.Binding('width'),
                        new go.Binding('height'),
                        g$(go.TextBlock, 
                        {
                            spacingAbove: 1.5,
                            name: "LABEL",
                            font: "{!LabelFont}",
                            stroke: "{!LabelColor}",
                            editable: true,
                            isMultiline: GetConfig("Roll").Label_Multiline__c,
                            textAlign: "center"
                        },
                        new go.Binding ("text").makeTwoWay())),
                ),
                g$(go.TextBlock, "",
                    {
                        name: "PALETTE_LABEL",
                        margin: 5,
                        font: "{!PaletteFont}",
                        width: 75
                    },
                    new go.Binding("text", "name"),
                ),
                {
                    mouseEnter: function(e, obj, prev)
                    {
                        StillActive();
                    },
                    mouseLeave: function(e, obj, next)
                    {
                        StillActive();
                    }
                }
            );

            var beltTemplate =
                g$(go.Node,
                {
                    selectionAdorned: false,
                    layerName: "Background",
                    copyable: true,
                    movable: false,
                    //toLinkable: true,
                    fromLinkable: false,
                    mouseDragEnter: function(e, belt)
                    {
                        var dragNode = diagram.toolManager.draggingTool.draggingParts.first();
                        if (dragNode == null ||
                            !dragNode.data.snapToBelt ||
                            dragNode.data.isFreeRoll == true ||
                            dragNode.data.onBelt != null ||
                            dragNode.data.snappedTo != null)
                        {
                            return;
                        }

                        var drag = dragNode.data.key;
                        var guides = belt.data.guides;
                        var nGuides = guides.length;

                        if (nGuides < 2)
                        {
                            if (nGuides == 1 && guides[0].k != drag)
                            {
                                Highlight (guides[0].k);
                            }
                        }
                        else
                        {
                            var shortest = FindSegment (e, belt);
                            if (shortest != null)
                            {
                                UnHighlight();

                                var prev = null;

                                for (var i = 0; i < nGuides; i++)
                                {
                                    if (guides[i].k == shortest.k)
                                        break;

                                    prev = guides[i];
                                }

                                if (prev == null)
                                    prev = guides[nGuides - 1];

                                //console.log ('between ' + shortest.k + ' and ' + prev.k);

                                if (shortest.k != drag && prev.k != drag)
                                {
                                    Highlight (shortest.k);
                                    Highlight (prev.k);
                                }
                            }
                        }
                    },
                    mouseDragLeave: function(e, belt)
                    {
                        var dragNode = diagram.toolManager.draggingTool.draggingParts.first();
                        if (dragNode == null ||
                            !dragNode.data.snapToBelt ||
                            dragNode.data.isFreeRoll == true ||
                            dragNode.data.onBelt != null ||
                            dragNode.data.snappedTo != null)
                        {
                            return;
                        }

                        var guides = belt.data.guides;
                        var nGuides = guides.length;
                        
                        if (nGuides < 2)
                        {
                            UnHighlight();
                        }
                        else
                        {
                            UnHighlight();
                        }
                    },
                    mouseDrop: function (e, belt)
                    {
                        var dragNode = diagram.toolManager.draggingTool.draggingParts.first();
                        if (dragNode == null ||
                            !dragNode.data.snapToBelt ||
                            dragNode.data.isFreeRoll == true ||
                            dragNode.data.onBelt != null ||
                            dragNode.data.snappedTo != null)
                        {
                            return;
                        }

                        var guides = belt.data.guides;
                        var nGuides = guides.length;
                        var drag =  dragNode.data.key;

                        //console.log ("drop " + drag + " onto belt");

                        var alreadyOnBelt = false;
                        for (var i = 0; i < nGuides; i++)
                        {
                            if (guides[i].k == drag)
                            {
                                alreadyOnBelt = true;
                                break;
                            }
                        }

                        if (nGuides < 2)
                        {
                            UnHighlight();
                            MakeSpare (dragNode);

                            if (nGuides == 0 || guides[0].k != drag)
                            {
                                dragNode.data.snappedTo = belt.data.key;
                                dragNode.data.snapChange = true;
                                dragNode.data.onBelt = belt.data.key;

                                guides.push ({k: drag, from: null, to: null});

                                UpdateAllBelts();
                            }
                        }
                        else
                        {
                            var shortest = FindSegment (e, belt);
                            if (shortest != null)
                            {
                                var prev = null;

                                for (var i = 0; i < nGuides; i++)
                                {
                                    if (guides[i].k == shortest.k)
                                        break;

                                    prev = guides[i];
                                }

                                if (prev == null)
                                    prev = guides[nGuides - 1];

                                //console.log ('drop between ' + shortest.k + ' and ' + prev.k);

                                if (shortest.k != drag && prev.k != drag)
                                {
                                    UnHighlight();
                                    MakeSpare (dragNode);

                                    dragNode.data.snappedTo = belt.data.key;
                                    dragNode.data.snapChange = true;
                                    dragNode.data.onBelt = belt.data.key;

                                    for (var i = 0; i < nGuides; i++)
                                    {
                                        if (guides[i].k == shortest.k)
                                        {
                                            guides.splice (i, 0, {k: drag, from: null, to: null});
                                            break;
                                        }
                                    }
                                    UpdateAllBelts();
                                }
                            }
                        }
                    }
                },
                g$(go.Shape,
                {
                    name: "BELT",
                    fill: "transparent",
                    strokeWidth: BELT_WIDTH_NORMAL
                },
                new go.Binding("stroke", "isSelected", function(s, e) { return BeltColor(s, e.part); }).ofObject(),
                {
                    mouseEnter: function(e, obj, prev)
                    {
                        StillActive();
                    },
                    mouseLeave: function(e, obj, next)
                    {
                        StillActive();
                    }
                })
            );

            var annotationStr = "M 150,0L 0,0L 0,600L 150,600 M 800,0";
            var annotationGeo = go.Geometry.parse(annotationStr);
            annotationGeo.normalize();
            go.Shape.defineFigureGenerator("Annotation", function(shape, w, h)
            {
                var geo = annotationGeo.copy();

                // calculate how much to scale the Geometry so that it fits in w x h
                var bounds = geo.bounds;

                var scaleW = w / bounds.width;
                var scaleH = h / bounds.height;

                geo.scale(scaleW, scaleH);

                return geo;
            });

            var circleNoteTemplate =
                g$(go.Node, "Auto",
                {
                    locationSpot: go.Spot.Center,
                    resizable: false,
                    resizeObjectName: "SHAPE"
                },
                new go.Binding("layerName", "lName"),
                new go.Binding("location", "loc", go.Point.parse).makeTwoWay(go.Point.stringify),
                g$(go.Shape, "Circle",
                {
                    name: "SHAPE",
                    portId: "",
                    fromLinkable: true,
                    cursor: "pointer",
                    fill: "{!CircleNoteBackground}",
                    strokeWidth: 0,
                    width: {!CircleNoteSize},
                    height: {!CircleNoteSize}
                }),
                g$(go.TextBlock, "{!$Label.Default_Note_Text}",
                {
                    font: "{!CircleNoteFont}",
                    stroke: "{!CircleNoteForeground}",
                    margin: 0,
                    editable: true,
                    isMultiline: false
                },
                new go.Binding("text").makeTwoWay(),
                {
                    mouseEnter: function(e, obj, prev)
                    {
                        StillActive();
                    },
                    mouseLeave: function(e, obj, next)
                    {
                        StillActive();
                    }
                })
            );

            var annotationTemplate =
                g$(go.Node, "Auto",
                {
                    background: GradientLightGray,
                    locationSpot: go.Spot.Center
                },
                new go.Binding("layerName", "lName"),
                new go.Binding("location", "loc", go.Point.parse).makeTwoWay(go.Point.stringify),
                g$(go.Shape, "Annotation", // A left bracket shape
                {
                    portId: "",
                    fromLinkable: true,
                    cursor: "pointer",
                    strokeWidth: 2,
                    stroke: "gray"
                }),
                g$(go.TextBlock, "{!$Label.Default_Note_Text}",
                {
                    font: "{!BoxNoteFont}",
                    margin: 5,
                    editable: true
                },
                new go.Binding("text").makeTwoWay(),
                {
                    mouseEnter: function(e, obj, prev)
                    {
                        StillActive();
                    },
                    mouseLeave: function(e, obj, next)
                    {
                        StillActive();
                    }
                })
            );

            var resizableArrowTemplate =
                g$(go.Node, "Auto",
                {
                    //rotatable: true,
                    movable: true,
                    resizable: true, resizeObjectName: "SHAPE", // user can resize the Shape
                    locationObjectName: "SHAPE",
                    //toLinkable: true,
                    fromLinkable: false,
                    locationSpot: go.Spot.Center,
                    resizeAdornmentTemplate: g$(go.Adornment, "Spot", // specify what resize handles there are and how they look
                        g$(go.Placeholder), // takes size and position of adorned object
                        g$(go.Shape, "Rectangle", // left resize handle
                        {
                            alignment: go.Spot.Left,
                            cursor: "col-resize",
                            desiredSize: new go.Size(6,6),
                            fill: "lightblue",
                            stroke: "dodgerblue"
                        }),
                        g$(go.Shape, "Rectangle", // right resize handle
                        {
                            alignment: go.Spot.Right,
                            cursor: "col-resize",
                            desiredSize: new go.Size(6,6),
                            fill: "lightblue",
                            stroke: "dodgerblue"
                        })),
                    selectionAdorned: false
                },
                new go.Binding("angle").makeTwoWay(),
                new go.Binding("layerName", "lName").makeTwoWay(),
                new go.Binding("location", "loc", go.Point.parse).makeTwoWay(go.Point.stringify),
                g$(go.Shape,
                {
                    name: "SHAPE",
                    //fill: "transparent",
                    strokeWidth: ARROW_WIDTH_NORMAL
                },
                new go.Binding("scale", "imageScale").makeTwoWay(),
                {
                    mouseEnter: function(e, obj, prev)
                    {
                        StillActive();
                    },
                    mouseLeave: function(e, obj, next)
                    {
                        StillActive();
                    }
                })
            );

            var nonresizableArrowTemplate =
                g$(go.Node, "Auto",
                {
                    rotatable: true,
                    movable: true,
                    resizable: false,
                    locationObjectName: "SHAPE",
                    //toLinkable: true,
                    fromLinkable: false,
                    locationSpot: go.Spot.Center
                },
                new go.Binding("angle").makeTwoWay(),
                new go.Binding("layerName", "lName").makeTwoWay(),
                new go.Binding("location", "loc", go.Point.parse).makeTwoWay(go.Point.stringify),
                g$(go.Shape,
                {
                    name: "SHAPE",
                    //fill: "transparent",
                    margin: 5,
                    strokeWidth: ARROW_WIDTH_NORMAL,
                    geometryStretch: go.GraphObject.None
                },
                new go.Binding("scale", "imageScale").makeTwoWay(),
                {
                    mouseEnter: function(e, obj, prev)
                    {
                        StillActive();
                    },
                    mouseLeave: function(e, obj, next)
                    {
                        StillActive();
                    }
                })
            );

            templateMap.add("", defaultNodeTemplate);
            templateMap.add("roll", rollTemplate);
            templateMap.add("placeholder", rollTemplate);
            templateMap.add("belt", beltTemplate);
            templateMap.add("annotation", annotationTemplate);
            templateMap.add("circleNote", circleNoteTemplate);
            templateMap.add("resizableArrow", resizableArrowTemplate);
            templateMap.add("nonresizableArrow", nonresizableArrowTemplate);

            diagram.nodeTemplateMap = templateMap;

            go.Shape.defineFigureGenerator("BpmnActivityLoop", function (shape, w, h) {
                        var geo = new go.Geometry(); var r = .5; var cx = 0;
                        // offset from Center x
                        var cy = 0;
                        // offset from Center y
                        var d = r * KAPPA;
                        var mx1 = (.4 * Math.SQRT2 / 2 + .5);
                        var my1 = (.5 - .5 * Math.SQRT2 / 2);
                        var x1 = 1;
                        var y1 = .5;
                        var x2 = .5;
                        var y2 = 0;
                        var fig = new go.PathFigure(mx1 * w, (1 - my1) * h, false);
                        geo.add(fig);
                        fig.add(new go.PathSegment(go.PathSegment.Bezier, x1 * w, y1 * h, x1 * w, .7 * h, x1 * w, y1 * h));
                        fig.add(new go.PathSegment(go.PathSegment.Bezier, (x2 + cx) * w, (y2 + cx) * h, (.5 + r + cx) * w, (.5 - d + cx) * h, (.5 + d + cx) * w, (.5 - r + cx) * h));
                        fig.add(new go.PathSegment(go.PathSegment.Bezier, (.5 - r + cx) * w, (.5 + cy) * h, (.5 - d + cx) * w, (.5 - r + cy) * h, (.5 - r + cx) * w, (.5 - d + cy) * h));
                        fig.add(new go.PathSegment(go.PathSegment.Bezier, (.35 + cx) * w, .9 * h, (.5 - r + cx) * w, (.5 + d + cy) * h, (.5 - d + cx) * w, .9 * h));
                        // Arrowheadfig.add(new go.PathSegment(go.PathSegment.Move, (.25 + cx) * w, 0.8 * h));
                        fig.add(new go.PathSegment(go.PathSegment.Line, (.35 + cx) * w, 0.9 * h));
                        fig.add(new go.PathSegment(go.PathSegment.Line, (.20 + cx) * w, 0.95 * h));
                        return geo;
                    });


            diagram.groupTemplate =
                g$(go.Group, "Auto", //"Vertical",
                    {
                        selectionObjectName: "PANEL",  // selection handle goes around shape, not label
                        ungroupable: true,
                        rotatable: false,
                        rotateObjectName: "GROUPSHAPE",
                        rotateAdornmentTemplate:
                        g$(go.Adornment,
                            {
                                locationSpot: go.Spot.Center,
                                background: "transparent"
                            },
                            g$(go.Shape, "BpmnActivityLoop",
                            {
                                width: 12,
                                height: 12,
                                stroke: COLOR_SELECTED,
                                strokeWidth: 2
                            })
                        )
                    },
                g$(go.Panel, "Auto",
                    {
                        name: "PANEL"
                    },
                    g$(go.Shape, "Rectangle",  // the rectangular shape around the members
                    {
                        name: "GROUPSHAPE",
                        fill: "rgba(224,224,224,0.1)",
                        stroke: "gray",
                        strokeWidth: 0.5,
                        portId: "",
                        //cursor: "pointer"//,  // the Shape is the port, not the whole Node

                        //fromLinkableSelfNode: true,
                        //fromLinkableDuplicates: true,
                        //toLinkable: true,
                        fromLinkable: false
                        //toLinkableSelfNode: true,
                        //toLinkableDuplicates: true
                    }),
                    g$(go.Placeholder,
                    {
                        margin: 10,
                        background: "transparent"
                    })  // represents where the members are
                )
            );

            diagram.addDiagramListener("BackgroundSingleClicked", function(e)
            {
                CloseMenu();
            });

            diagram.addDiagramListener("ClipboardChanged", function(e)
            {
                //console.log ('clipboard changed');

                for (var it = e.subject.iterator; it.next() ; )
                {
                    it.value.data.copiedFrom = it.value.data.key;
                }
            });

            diagram.addDiagramListener("ClipboardPasted", function(e)
            {
                var oldToNew = new Object();

                for (var it = e.diagram.selection.iterator; it.next() ; )
                {
                    var node = it.value;
                    if (node.data)
                        oldToNew[node.data.copiedFrom] = node.data.key;
                }

                CopyBelts(oldToNew);
                CopyPartMetadata(oldToNew);

                for (var it = e.diagram.selection.iterator; it.next() ; )
                {
                    var node = it.value;

                    NewPart(node);
                    HideText(node);
                    FixUpNode(node);
                    SetupSnap(node);

                    // move the new node a bit so it's clear to the user - there's no visual indication
                    // that anything happened if we just leave it at the same place
                    node.isSelected = true;
                    var loc = node.location.copy();
                    loc.x += 10;
                    loc.y += 10;

                    node.location = loc;
                }
            });

            diagram.addDiagramListener("ExternalObjectsDropped", function(e) // from palette
            {
                //console.log("external objects dropped");

                var beltsUpdated = false;
                var resetBelts = false;
                var removeParts = [];

                for (var it = e.subject.iterator; it.next() ; )
                {
                    var node = it.value;
                    var prevSnap = node.data.snappedTo;

                    if (node.data.objectType == 'Doctor')
                    {
                        var shape = node.findObject("SHAPE");
                        var pic = docImages[node.data.recordType];

                        if (pic != null)
                        {
                            node.data.source = pic;
                            shape.source = pic;
                        }
                    }

                    NewPart(node);
                    HideText(node);
                    FixUpNode(node);

                    node.data.snappedTo = prevSnap;

                    if (node.data.autosize)
                    {
                        var shape = node.findObject("GUIDE");
                        shape.width = node.data.autosize;
                        shape.height = node.data.autosize;
                        shape.scale = 1.0;
                    }

                    if (node.category == "placeholder")
                    {
                        //console.log("PlaceHolder");

                        var guide = node.findObject("GUIDE");
                        guide.strokeDashArray = [6, 3];
                        guide.scale = 1.0;

                        var label = node.findObject("LABEL");
                        label.editable = false;
                        label.text = null;
                    }
                    else
                    if (node.category == "dynamicLine")
                    {
                        //console.log("new dynamic line");

                        // dunno why this gets lost - make sure it's set
                        diagram.model.linkKeyProperty = "key";

                        removeParts.push(node.part);

                        var left = node.location.copy();
                        var right = node.location.copy();

                        left.x += 50;
                        right.x -= 50;


                        var config = GetConfig(node.data.recordType);

                        var linkData =
                        {
                            category: "dynamicLine",
                            points: new go.List().addAll([left, right]),
                            toLinkable: true,
                            fromLinkable: true
                        };

                        diagram.startTransaction("add dynamic link");

                        diagram.toolManager.linkingTool.isUnconnectedLinkValid = true;
                        diagram.toolManager.relinkingTool.isUnconnectedLinkValid = true;

                        diagram.model.addLinkData(linkData);

                        diagram.toolManager.linkingTool.isUnconnectedLinkValid = dynamicLineSelected;
                        diagram.toolManager.relinkingTool.isUnconnectedLinkValid = dynamicLineSelected;

                        var link = diagram.findLinkForData(linkData);
                        if (link)
                        {
                            //console.log("findLinkForData!");

                            var shape = link.findObject("ARROWS");
                            if (shape)
                            {
                                shape.toLinkable = config.Allow_Link_To__c;
                                shape.fromLinkable = config.Allow_Link_From__c;

                                if (node.data.arrowBegin)
                                {
                                    shape.toArrow = ARROW_TYPE;
                                    shape.fill = "black";
                                }
                                else
                                {
                                    shape.toArrow = ARROW_NONE;
                                    shape.fill = null;
                                }
                            }
                        }

                        diagram.commitTransaction("add dynamic link");
                    }

                    if (node.category == "belt")
                    {                                        
                        isSheetPath = false;
                        if (node.recordType == 'Sheet Path')
                        {
                            isSheetPath = true;
                        }
                        
                        var center = node.location;
                        var where = center.copy();
                        where.x += {!AutoRollOffet};
                        var count = node.data.autoroll;
                        node.data.autoroll = 0;
                        node.data.guides = [];

                        for (var i = 0; i < count; i++)
                        {
                            resetBelts = true;

                            var deg = 360 / count * i;

                            var rollLoc = RotatePoint (where, center, deg);

                            var roll =
                            {
                                category: "roll",
                                loc: rollLoc.x + " " + rollLoc.y,
                                outside: false
                            };

                            e.diagram.model.addNodeData(roll);

                            var newRoll = e.diagram.findNodeForKey(roll.key);

                            newRoll.data.name = "Roll";
                            newRoll.data.sObjectType = "Machine_Mapping_Roll__c";
                            newRoll.data.recordType = "Roll";
                            newRoll.data.source = "{!$Resource.Roll}";
                            newRoll.data.objectType = "Roll";
                            newRoll.data.dirty = true;
                            newRoll.data.snappedTo = node.data.key;
                            newRoll.data.onBelt = node.data.key;
                            newRoll.data.snapChange = true;
                            newRoll.data.snapToBelt = true;                       

                            var guide = newRoll.findObject("GUIDE");
                            if (guide)
                            {
                                var size = {!AutoRollAddSize} * {!RollSizeMultiplier};
                                guide.width = size;
                                guide.height = size;
                            }                            
                            
                            node.data.guides.push ({ k: roll.key, from: null, to: null });

                            NewPart(newRoll);
                            HideText(newRoll);
                        }

                        if (!beltsUpdated)
                        {
                            beltsUpdated = true;
                            UpdateBelt(node);
                        }

                        updateDirty();
                    }
                    else
                    if (prevSnap != null)
                    {
                        //console.log("prevSnap is Null");
                        // if we do this on the current stack, the sizes will be screwy and the snap
                        // won't come out right.. unwind first
                        setTimeout(function()
                        {
                            diagram.startTransaction("snap node");
                            SnapToKey (node, prevSnap);
                            diagram.commitTransaction("snap node");
                        }, 1);
                    }
                    else
                    {
                        //console.log("ELSE, falling through");
                        SetupSnap(node);
                    }
                }

                if (removeParts.length > 0)
                {
                    diagram.startTransaction("cleanup dropped links");
                    for (var i = 0; i < removeParts.length; i++)
                    {
                        diagram.remove(removeParts[i]);
                    }
                    diagram.commitTransaction("cleanup dropped links");
                }

                if (resetBelts)
                    setTimeout(UpdateAllBelts, 1);
            });

            diagram.addDiagramListener("InitialLayoutCompleted", function(e)
            {
                //console.log ("InitialLayoutCompleted");
                LoadMetadata();
                UpdateAllBelts();

                for (var it = diagram.nodes.iterator; it.next() ; )
                {
                    var node = it.value;
                    if (node.data.snapping)
                    {
                        if (node.category == "resizableArrow" || node.category == "nonresizableArrow")
                            FixArrowShape (node);
                    }
                }

                // weird things happen to stuff like roll widths if i don't it unwind before
                // fixing up the snappings
                setTimeout (FixNodes, 1);
            });

            diagram.addDiagramListener("LinkRelinked", function(e)
            {
                //console.log("LinkRelinked");

                diagramDirty = true;

                if (e && e.parameter)
                {
                    var part = e.parameter.part;

                    if (part && part.data && part.data.filterNumber)
                    {
                        delete part.data.filterNumber;
                        part.data.filterChange = true;
                    }

                    HandleLinkDrawn(e);
                }
            });

            diagram.addDiagramListener("LinkDrawn", function(e)
            {
                HandleLinkDrawn(e);
            });

            diagram.addDiagramListener("ObjectDoubleClicked", function (e)
            {
                var part = e.subject.part;
                var to = part.data ? part.data.snappedTo : null;
                if (part.category == "belt" && part.data.guides)
                {
                    var rolls = new go.List();
                    var guides = part.data.guides;

                    for (var i = 0; i < guides.length; i++)
                    {
                        var roll = diagram.findNodeForKey(guides[i].k);

                        rolls.add (roll);
                    }

                    diagram.clearSelection();
                    diagram.selectCollection(rolls);
                }
                else
                if (part.category == "group")
                {
                    var parts = new go.List();
                    var groupKey = e.subject.part.data.key;

                    for (var it = diagram.nodes.iterator; it.next() ; )
                    {
                        if (it.key.data.group == groupKey)
                        {
                            parts.add (it.key);
                        }
                    }
                    diagram.clearSelection();
                    diagram.selectCollection(parts);
                }
            });

            diagram.addDiagramListener("SelectionCopied", function(e)
            {
                var oldToNew = new Object();
                var oldIds = [];
                var sawBelt = false;

                for (var it = diagram.toolManager.draggingTool.draggedParts.iterator; it.next() ; )
                {
                    var k = it.key.data.key;

                    oldIds.push (k);
                    sawBelt |= it.key.category == "belt";
                }

                for (var i = 0, it = e.diagram.selection.iterator; it.next() ; i++)
                {
                    var node = it.value;
                    //console.log ("selected " + node);

                    if (node.data)
                        oldToNew[oldIds[i]] = node.data.key;

                    NewPart(node);
                    HideText(node);
                    FixUpNode(node);
                    SetupSnap(node);
                }

                if (sawBelt)
                    CopyBelts(oldToNew);

                CopyPartMetadata(oldToNew);
            });

            diagram.addDiagramListener("SelectionDeleting", function(e)
            {
                for (var iter = diagram.selection.iterator; iter.next(); )
                {
                    var part = iter.value;
                    if (part.category == "circleNote" || part.category == "annotation")
                    {
                        // we're a link if we have a from and a to... reset back to the notes
                        // layer if we have those
                        if (part.toNode && part.fromNode)
                        {
                            part.fromNode.layerName = "Notes";
                            part.fromNode.data.lName = "Notes";
                        }
                    }
                }
            });

            diagram.addDiagramListener("SelectionDeleted", function (e)
            {
                e.subject.each(function (node)
                {
                    var data = node.data;
                    if (data)
                    {
                        if (data.objectId)
                            deletedNodes.push(data.objectId);

                        if (data.snappedTo)
                        {
                            UpdateAllBelts(); // todo: only update needed belts

                            UpdateRollLabelFromKey(data.snappedTo);
                        }

                        // note hard deletes below - want to remove the property, not just null it out
                        if (node.toNode && node.toNode.data && node.toNode.data.filterNumber)
                        {
                            var toData = node.toNode.data;

                            delete toData.filterNumber;
                            toData.dirty = true;
                            toData.filterChange = true;
                        }

                        if (node.fromNode && node.fromNode.data && node.fromNode.data.filterNumber)
                        {
                            var fromData = node.fromNode.data;

                            delete fromData.filterNumber;
                            fromData.dirty = true;
                            fromData.filterChange = true;
                        }
                    }
                });
            });

            diagram.addDiagramListener("TextEdited", function(e)
            {
                var tb = e.subject;
                var node = tb.part;
                var nodeData = node.data;
                var nodeKey = nodeData.key;
                var vals = metadataVals[nodeKey];
                var config = GetConfig(nodeData.recordType);

                if (config && config.Label_Field__c && vals != null)
                {
                    var field = config.Label_Field__c;
                    var newText = tb.text;
                    vals[field] = newText;
                    j$("#" + field).val(newText);
                }

                nodeData.dirty = true;

                updateDirty();
            });

            diagram.addDiagramListener("ViewportBoundsChanged", function(e)
            {
                FixViewport(e.diagram);
            });

            function FixNodes()
            {
                diagram.startTransaction("post load fixup");

                for (var it = diagram.nodes.iterator; it.next() ; )
                {
                    var node = it.value;
                    if (node.data.snapping)
                    {
                        SnapToKey (node, node.data.snappedTo);
                    }
                }

                diagram.commitTransaction("post load fixup");
            }

            <apex:outputText rendered="{!IsReadOnly = false}" escape="false">

                jQuery("#palette").accordion(
                {
                    active: false,
                    heightStyle: "content",
                    collapsible: true,
                    activate: function(event, ui)
                    {
                        // tell gojs that a div changed size but that the window didn't
                        <apex:repeat value="{!PaletteGroupKeys}" var="pg">
                            myPalette{!pg}.requestUpdate();
                        </apex:repeat>
                        myPaletteNotes.requestUpdate();
                    }
                });

                // each accordion section is a separate gojs palette
                <apex:repeat value="{!PaletteGroupKeys}" var="pg">
                    var myPalette{!pg} = g$(go.Palette, "myPalette{!pg}",
                    {
                        nodeTemplate: defaultNodeTemplate,
                        layout: g$(go.GridLayout, { wrappingColumn: 1, alignment: go.GridLayout.Position })
                    });

                    myPalette{!pg}.model = new go.GraphLinksModel (
                    [
                        <apex:repeat value="{!PaletteEntries[pg]}" var="pe">

                            <apex:outputText rendered="{!pe.ObjectType != 'Machine_Mapping_Roll__c'}">
                                <apex:outputText value="," rendered="{!pe.IsFirst = false}"/>
                                {
                                    name: "{!pe.RecTypeLabel}",
                                    source: "{!$Resource[KeyToIcon[pe.RecTypeLabel]]}",
                                    imageScale: GetPaletteScale ("{!pe.RecTypeLabel}"),
                                    sObjectType: "{!pe.ObjectType}",
                                    recordType: "{!pe.RecTypeLabel}",
                                    objectType: "{!pe.ObjectLabel}",
                                    lName: "{!pg}",
                                    inPalette: true,
                                    snapChange: false,
                                    snappedTo: ""
                                    <apex:outputText rendered="{!pe.ObjectType = 'Machine_Mapping_Belt__c'}">
                                        ,category: "belt"
                                    </apex:outputText>
                                    <apex:outputText rendered="{!pe.ObjectType = 'Machine_Mapping_Cleaning__c'}">
                                        ,category: "cleaning"
                                    </apex:outputText>
                                    <apex:outputText rendered="{!pe.ObjectType = 'Machine_Mapping_Doctor__c'}">
                                        ,snapping: "outside"
                                        ,snapTo: "roll"
                                    </apex:outputText>
                                    <apex:outputText rendered="{!pe.ObjectType = 'Machine_Mapping_Accessory__c'}">
                                        ,snapping: "outside"
                                        ,snapTo: "cleaning"
                                        ,category: "accessory"
                                    </apex:outputText>
                                    <apex:outputText rendered="{!pe.ObjectType = 'Machine_Mapping_Rotary_Joint__c'}">
                                        ,snapping: "inside"
                                        ,snapTo: "roll"
                                    </apex:outputText>
                                }
                            </apex:outputText>
                        </apex:repeat>

                        <apex:outputText rendered="{!pg = 'Roll'}">
                            {
                                name: "{!$Label.Placeholder_Roll}",
                                source: "{!$Resource.Roll}",
                                imageScale: GetPaletteScale("Roll"),
                                category: "placeholder",
                                objectType: "Roll",
                                snapToBelt: true,
                                snapTo: "roll",
                                outside: true,
                                snappedToRoll: null,
                                snapping: "under"
                            }
                            <apex:repeat value="{!AutoRollSizeValues}" var="ars">
                                ,{
                                    name: 'Roll - {!ars}"',
                                    source: "{!$Resource.Roll}",
                                    imageScale: GetPaletteScale ("Roll"),
                                    inPalette: true,
                                    category: "roll",
                                    sObjectType: "Machine_Mapping_Roll__c",
                                    recordType: "Roll",
                                    objectType: "Roll",
                                    autosize: {!ars} * {!RollSizeMultiplier},
                                    isFreeRoll: false,
                                    snapToBelt: true
                                }
                            </apex:repeat>
                        </apex:outputText>

                        <apex:outputText rendered="{!pg = 'Belt'}">
                            <apex:repeat value="{!AutoRollValues}" var="arv">
                            ,{
                                name: "Belt and {!arv} Rolls",
                                source: "{!$Resource.Belt}",
                                imageScale: GetPaletteScale ("Belt"),
                                inPalette: true,
                                category: "belt",
                                sObjectType: "Machine_Mapping_Belt__c",
                                recordType: "Belt",
                                objectType: "Belt",
                                autoroll: {!arv},
                                guides: []
                            }
                            </apex:repeat>
                            ,{
                                name: "Sheet Path",
                                source: "{!$Resource.Sheet_Path}",
                                imageScale: GetPaletteScale ("Belt"),
                                inPalette: true,
                                category: "belt",
                                sObjectType: "Machine_Mapping_Belt__c",
                                recordType: "Sheet Path",
                                objectType: "Sheet Path",
                                autoroll: 3,
                                guides: []
                            }                                            
                        </apex:outputText>
                    ]);

                </apex:repeat>

                var myPaletteNotes = g$(go.Palette, "myPaletteNotes",
                {
                    nodeTemplate : defaultNodeTemplate,
                    layout: g$(go.GridLayout, { wrappingColumn: 1, alignment: go.GridLayout.Position })
                });

                myPaletteNotes.model = new go.GraphLinksModel(
                [
                    {
                        name: "Note",
                        category: "annotation",
                        text: "Note",
                        lName: "Notes",
                        imageScale: GetPaletteScale ("Note"),
                        inPalette: true,
                        source: "{!$Resource.Note}"
                    },
                    {
                        name: "Circle Note",
                        category: "circleNote",
                        text: "Note",
                        lName: "Notes",
                        imageScale: GetPaletteScale ("Circle Note"),
                        inPalette: true,
                        source: "{!$Resource.Circle_Note}"
                    },
                    {
                        name: "Single Line",
                        category: "dynamicLine",
                        lName: "Notes",
                        arrowBegin: false,
                        arrowEnd: false,
                        inPalette: true,
                        imageScale: GetPaletteScale ("Single Line"),
                        source: "{!$Resource.Line}"
                    },
                    {
                        name: "Single Arrow",
                        category: "dynamicLine",
                        lName: "Notes",
                        arrowBegin: true,
                        arrowEnd: false,
                        inPalette: true,
                        imageScale: GetPaletteScale ("Single Arrow"),
                        source: "{!$Resource.ArrowSingle}"
                    },
                    {
                        name: "Stretch Arrow",
                        category: "nonresizableArrow",
                        lName: "Notes",
                        snapping: "inside",
                        snapTo: "roll",
                        snapSize: 0,
                        arrowBegin: true,
                        arrowEnd: true,
                        imageScale: GetPaletteScale ("Double Arrow"),
                        inPalette: true,
                        source: "{!$Resource.ArrowStraight}"
                    },
                    {
                        name: "Outside Arrow",
                        category: "nonresizableArrow",
                        lName: "Notes",
                        snapping: "outside",
                        snapTo: "roll",
                        snapSize: 0,
                        arrowEnd: true,
                        imageScale: GetPaletteScale ("Outside Arrow"),
                        inPalette: true,
                        source: "{!$Resource.ArrowRound}"
                    }
                ]);

            </apex:outputText>

            var w = new go.Layer();
            w.name = 'Watermarks';
            w.isTemporary = true;

            diagram.addLayer(w);

            diagram.add(
                g$(go.Part,
                {
                    layerName: "Watermarks",
                    _viewPosition: new go.Point(-1, -1),
                    selectable: false,
                    name: 'title'
                },
                g$(go.TextBlock, "{!MapTitle}",
                {
                    font: "bold 10pt sans-serif"
                })
            ));

            diagram.add(
                g$(go.Part,
                {
                    layerName: "Watermarks",
                    _viewPosition: new go.Point(-1, -1),
                    selectable: false,
                    name: 'copyright'
                },
                g$(go.TextBlock, " " + new Date().getFullYear() + " Kadant Inc.", // todo: why doesn't &copy; work?
                {
                    font: "bold 10pt sans-serif"
                })
            ));

            diagram.add(
                g$(go.Part,
                {
                    layerName: "Watermarks",
                    _viewPosition: new go.Point(-1, -1),
                    selectable: false,
                    name: 'kadantImage'
                },
                g$(go.Picture,
                {
                    width: (265 / 2),
                    height: (46 / 2),
                    source: '{!$Resource.KadantLogo}'
                })
            ));

        } // init


        function HandleLinkDrawn(e)
        {
            //console.log("HandleLinkDrawn");

            var subj = e.subject;
            if (subj && subj.fromNode)
            {
                if (subj.fromNode.category === "annotation")
                    subj.category = "annotation";
                else
                if (subj.fromNode.category === "circleNote")
                    subj.category = "circleNote";
                else
                if (subj.fromNode.data && subj.toNode.data)
                {
                    var filter;
                    var other;

                    if (subj.fromNode.data.sObjectType == FILTER_CLASS)
                    {
                        filter = subj.fromNode.data;
                        other  = subj.toNode.data;
                    }
                    else
                    if (subj.toNode.data.sObjectType == FILTER_CLASS)
                    {
                        filter = subj.toNode.data;
                        other  = subj.fromNode.data;
                    }

                    if (filter && other)
                    {
                        var config = GetConfig(other.recordType);
                        if (config && config.Filter_Field__c && config.Filter_Field__c != "")
                        {
                            //console.log("link filter " + filter.key + " to " + other.key +
                                //" on field " + other.sObjectType + "." + config.Filter_Field__c);

                            other.filterNumber = filter.key;
                            other.filterChange = true;
                        }
                    }
                }

                switch (subj.fromNode.category)
                {
                    case "annotation":
                    case "circleNote":
                        subj.fromNode.layerName = subj.toNode.part.layerName;
                        subj.fromNode.data.lName = subj.toNode.part.layerName;
                        break;

                    default:
                        break;
                }
            }
        }

        function BeltColor (isSelected, belt)
        {
            if (isSelected)
                return COLOR_SELECTED;

            var guides = belt.data.guides;
            if (guides.length < 1)
                return COLOR_ERROR;

            if (guides.length < 2)
                return COLOR_ERROR2;

            if (belt.data.color)
                return belt.data.color;

            return COLOR_NORMAL;
        }

        function MakeSpare (node)
        {
            var key = node.data.key;
            var madeChange = false;

            diagram.startTransaction("make spare");

            for (var it = diagram.nodes; it.next() && !madeChange ; )
            {
                var belt = it.value;

                if (belt && belt.category == "belt")
                {
                    var guides = belt.data.guides;

                    for (var i = 0; i < guides.length && !madeChange; i++)
                    {
                        if (guides[i].k == key)
                        {
                            node.data.snapChange = true;
                            node.data.snappedTo = null;
                            node.data.onBelt = null;

                            guides.splice (i, 1);
                            madeChange = true;
                        }
                    }
                }

                if (node.category == "placeholder")
                {
                    node.movable = true;

                    var shape = node.findObject("GUIDE");
                    shape.visible = true;
                    shape.strokeDashArray = [6, 3];
                }
            }

            var shape = diagram.findNodeForKey(key).findObject("GUIDE");
            if (shape != null)
            {
                shape.stroke = COLOR_NORMAL;
                shape.strokeWidth = WIDTH_NORMAL;
            }

            diagram.commitTransaction("make spare");
        }

        function FindSegment (e, node)
        {
            var x0 = e.documentPoint.x;
            var y0 = e.documentPoint.y;

            var guides = node.data.guides;
            var nGuides = guides.length;
            var shortest = null;
            var shortestLen;

            for (var i = 0; i < nGuides; i++)
            {
                var g = guides[i];

                if (g.from == null || g.to == null)
                    return null;

                var x1 = g.from.x;
                var y1 = g.from.y;

                var x2 = g.to.x;
                var y2 = g.to.y;

                var dx = x2 - x1;
                var dy = y2 - y1;

                var dist = Math.abs(dy * x0 - dx * y0 - x1 * y2 + x2 * y1) / Math.sqrt((dx * dx) + (dy * dy));

                if (shortest == null || dist < shortestLen)
                {
                    shortest = g;
                    shortestLen = dist;
                }
            }

            return shortest;
        }

        function Highlight(key)
        {
            ChangeStyle (key, 'red', 'white');

            highlights.push (key);
        };

        function UnHighlight()
        {
            for (var i = 0; i < highlights.length; i++)
                ChangeStyle (highlights[i], 'transparent', 'red');

            highlights = [];
        };

        function ChangeStyle (key, fill, textColor)
        {
            var node = diagram.findNodeForKey(key);
            var shape;

            shape = node.findObject("GUIDE");
            if (shape != null)
                shape.fill = fill;

            shape = node.findObject("PALETTE_LABEL"); // ?
            if (shape != null)
                shape.stroke = textColor;
        }

        function UpdateAllBelts()
        {
            diagram.startTransaction("update all belts");

            for (var it = diagram.nodes; it.next() ; )
            {
                var node = it.value;
                if (node.data.snapToBelt)
                    node.data.forceBeltError = false;
            }

            diagram.nodes.each(function(n)
            {
                if (n.category === "belt")
                    UpdateBelt(n);
            });

            diagram.commitTransaction("update all belts");
        }


        function UpdateBelt(belt)
        {            
            var d = belt.diagram;            

            var guideinfos = belt.data.guides;

            var guides = [];
            var keys = new go.Set();            
            
            var shape = belt.findObject("BELT");
            isSheetPath = false;                            
            if (belt.data.recordType == 'Sheet Path')
            {
                isSheetPath = true;
            }

            for (var i = 0; i < guideinfos.length; i++)
            {
                var guide = guideinfos[i];
                var key = guide.k;

                var guidenode = d.findNodeForKey(key);
                if (guidenode == null || keys.contains(key))
                {
                    // node was deleted - shoot the guide, too
                    //console.log ('key ' + key + ' no longer found or dup');
                    guideinfos.splice (i--, 1);
                }
                else
                {
                    keys.add (key);

                    var guideShape = null;

                    if (guidenode.category == "placeholder" && guidenode.data.snappedTo != null)
                    {
                        var actualKey = guidenode.data.snappedTo;
                        var actualNode = d.findNodeForKey(actualKey);  
                        guideShape = actualNode.findObject("GUIDE");
                    }

                    if (guideShape == null)
                        guideShape = guidenode.findObject("GUIDE");

                    if (guideShape == null || guideShape.measuredBounds == null)
                    {
                        console.log ("no shape!");
                    }                    

                    var radius = (guideShape.measuredBounds.width / 2) - 0.5;

                    // todo: can we cache these so we redraw only what's needed?
                    guide.from = null;
                    guide.to = null;

                    var tmp =
                    {
                        name: key,
                        node: guidenode,
                        guide: guideShape,
                        location: guidenode.location.copy(),
                        radius: radius,
                        outside: !!guidenode.data.outside,
                        from: null,
                        to: null
                    };

                    guides.push (tmp);
                }
            }

            var shape = belt.findObject("BELT");
            if (shape != null)
                shape.stroke = BeltColor (false, belt);

            if (guides.length < 2)
            {
                var geo = new go.Geometry();
                var fig;

                console.log('In UpdateBelt guides length < 2');

                if (guides.length === 1)
                {
                    // single guide - draw a circle around it
                    var guide = guides[0];
                    var guideNode = guide.node;

                    var nodeShape = guideNode.findObject("GUIDE");

                    var w = nodeShape.width + 10;
                    var h = nodeShape.height + 10;
                    var r = w / 2;

                    fig = new go.PathFigure(r, 0);
                    fig.add(new go.PathSegment(go.PathSegment.Arc, 0, 360, 0, 0, r, r));

                    geo.add(fig);

                    shape.geometry = geo;
                    shape.stroke = "darkred";
                    shape.strokeWidth = BELT_WIDTH_ERROR;
                    shape.strokeDashArray = BELT_DASH_ERROR;

                    var halfS = shape.strokeWidth / 2;

                    belt.location = new go.Point(guide.location.x - r - halfS, guide.location.y - r - halfS);
                }
                else
                {
                    var w = 30;
                    var h = 30;
                    var r = w / 2;

                    fig = new go.PathFigure(r, 0);
                    fig.add(new go.PathSegment(go.PathSegment.Arc, 0, 360, 0, 0, r, r));

                    geo.add(fig);

                    shape.geometry = geo;
                    shape.stroke = COLOR_ERROR;
                    shape.strokeWidth = BELT_WIDTH_ERROR;
                    shape.strokeDashArray = BELT_DASH_ERROR;
                }

                return;
            }

            // compute the contact points
            for (var i = 0; i < guides.length; i++)
            {
                var guide = guides[i];
                var next = guides[(i + 1) % guides.length];
                computeContacts(guide, next);
            }            

            var prev = null;
            for (var i = 0; i <= guides.length; i++)
            {
                var x = i % guides.length;
                var guide = guides[x];

                if (prev != null)
                    guideinfos[x].from = prev.from;

                guideinfos[x].to = guide.to;

                prev = guide;
            }

            var geo = new go.Geometry();
            var fig = null;
            
            // Add Sheet Path handling here!!  minus 1 from guides
            var numGuides = guides.length;
            if (isSheetPath)
            {
                numGuides = guides.length - 1;
            }            

            for (var i = 0; i < numGuides; i++)
            {
                var guide = guides[i];
                var next = guides[(i + 1) % guides.length];
                var follow = guides[(i + 2) % guides.length];

                var wasError = next.guide.part.data.beltError;                
                var isError = PointsIntersect(guide.from, next.to, next.from, follow.to) || next.node.data.forceBeltError;

                if (isError && next.node.category == "placeholder" && next.node.data.snappedTo != null)
                {
                    // a snapped placeholder is in error - force the error onto the actual roll
                    var actualKey = next.node.data.snappedTo;
                    var actualNode = d.findNodeForKey(actualKey);

                    actualNode.data.forceBeltError = true;
                }

                if (wasError != isError)
                {
                    next.guide.part.data.beltError = isError;

                    if (isError)
                    {
                        next.guide.stroke = COLOR_ERROR;
                        next.guide.strokeWidth = WIDTH_ERROR;
                    }
                    else
                    {
                        next.guide.stroke = next.node.isSelected ? COLOR_SELECTED : COLOR_NORMAL;
                        next.guide.strokeWidth = next.node.isSelected ? WIDTH_SELECTED : WIDTH_NORMAL;
                    }
                }

                if (fig === null)
                {
                    fig = new go.PathFigure(guide.from.x, guide.from.y, true);
                    geo.add(fig);
                }                

                fig.add(new go.PathSegment(go.PathSegment.Line, next.to.x, next.to.y));

                var startang = next.location.directionPoint(next.to);
                var endang = next.location.directionPoint(next.from);
                var sweep = (endang > startang) ? endang - startang : (360 - startang) + endang;

                var sw = next.outside ? (sweep - 360) : sweep;

                if (next.outside)
                {
                    // go counter-clockwise
                    fig.add(new go.PathSegment(go.PathSegment.Arc, startang, sweep - 360, next.location.x, next.location.y, next.radius, next.radius));
                }
                else
                {
                    // positive sweep angle
                    fig.add(new go.PathSegment(go.PathSegment.Arc, startang, sweep,    next.location.x, next.location.y, next.radius, next.radius));
                }
            }

            // update the belt's Shape.geometry
            if (shape !== null)
            {
                var pos = geo.normalize();
                shape.geometry = geo;
                shape.strokeDashArray = BELT_DASH_NORMAL;
                shape.strokeWidth = BELT_WIDTH_NORMAL;
                belt.position = new go.Point(-pos.x - shape.strokeWidth / 2, -pos.y - shape.strokeWidth / 2);
            }
        }

        function comparePointWithLine(a1x, a1y, a2x, a2y, p1x, p1y)
        {
            var x2 = a2x - a1x;
            var y2 = a2y - a1y;
            var px = p1x - a1x;
            var py = p1y - a1y;
            var ccw = px * y2 - py * x2;

            if (ccw === 0)
            {
                ccw = px * x2 + py * y2;

                if (ccw > 0)
                {
                    px -= x2;
                    py -= y2;
                    ccw = px * x2 + py * y2;

                    if (ccw < 0)
                        ccw = 0;
                }
            }
            return (ccw < 0) ? -1 : ((ccw > 0) ? 1 : 0);
        }

        function computeContacts(guideA, guideB)
        {
            var locA = guideA.location;
            var x1 = locA.x;
            var y1 = locA.y;
            var r1 = guideA.radius;
            var locB = guideB.location;
            var x2 = locB.x;
            var y2 = locB.y;
            var r2 = guideB.radius;

            // this assumes that belts only go clockwise
            var g = Math.atan2(y2 - y1, x2 - x1);
            var d = Math.sqrt((x2 - x1) * (x2 - x1) + (y2 - y1) * (y2 - y1));

            var bb = ((guideA.outside === guideB.outside) ? (r2 - r1) : (r2 + r1)) / d;

            if (bb < -1)
                bb = -1;
            else
            if (bb > 1)
                bb = 1;

            var b = Math.asin(bb);

            if (guideB.outside)
            {
                if (guideA.outside)
                {
                    // both outside
                    var a = Math.PI / 2 - b - g;
                    var cosa = Math.cos(a);
                    var sina = Math.sin(a);
                    guideA.from = new go.Point(x1 - r1 * cosa, y1 + r1 * sina);
                    guideB.to = new go.Point(x2 - r2 * cosa, y2 + r2 * sina);
                }
                else
                {
                    // inside A, outside B
                    var a = Math.PI / 2 - Math.abs(b) - g;
                    var cosa = Math.cos(a);
                    var sina = Math.sin(a);
                    guideA.from = new go.Point(x1 + r1 * cosa, y1 - r1 * sina);
                    guideB.to = new go.Point(x2 - r2 * cosa, y2 + r2 * sina);
                }
            }
            else
            {
                if (guideA.outside)
                {
                    // outside A, inside B
                    var a = Math.abs(b) - Math.PI / 2 - g;
                    var cosa = Math.cos(a);
                    var sina = Math.sin(a);
                    guideA.from = new go.Point(x1 + r1 * cosa, y1 - r1 * sina);
                    guideB.to = new go.Point(x2 - r2 * cosa, y2 + r2 * sina);
                }
                else
                {
                    // both inside
                    var a = Math.PI / 2 + b - g;
                    var cosa = Math.cos(a);
                    var sina = Math.sin(a);
                    guideA.from = new go.Point(x1 + r1 * cosa, y1 - r1 * sina);
                    guideB.to = new go.Point(x2 + r2 * cosa, y2 - r2 * sina);
                }
            }
        }

        function PointsIntersect(p1, p2, p3, p4)
        {
            return LinesIntersect (p1.x, p1.y, p2.x, p2.y, p3.x, p3.y, p4.x, p4.y);
        }

        function LinesIntersect(x1, y1, x2, y2, x3, y3, x4, y4)
        {
            var a1, a2, b1, b2, c1, c2;
            var r1, r2 , r3, r4;
            var denom, offset, num;

            // Compute a1, b1, c1, where line joining points 1 and 2
            // is "a1 x + b1 y + c1 = 0".
            a1 = y2 - y1;
            b1 = x1 - x2;
            c1 = (x2 * y1) - (x1 * y2);

            // Compute r3 and r4.
            r3 = ((a1 * x3) + (b1 * y3) + c1);
            r4 = ((a1 * x4) + (b1 * y4) + c1);

            // Check signs of r3 and r4. If both point 3 and point 4 lie on
            // same side of line 1, the line segments do not intersect.
            if ((r3 !== 0) && (r4 !== 0) && SameSign(r3, r4))
                return 0; //return that they do not intersect

            // Compute a2, b2, c2
            a2 = y4 - y3;
            b2 = x3 - x4;
            c2 = (x4 * y3) - (x3 * y4);

            // Compute r1 and r2
            r1 = (a2 * x1) + (b2 * y1) + c2;
            r2 = (a2 * x2) + (b2 * y2) + c2;

            // Check signs of r1 and r2. If both point 1 and point 2 lie
            // on same side of second line segment, the line segments do
            // not intersect.
            if ((r1 !== 0) && (r2 !== 0) && (SameSign(r1, r2)))
                return 0; //return that they do not intersect

            //Line segments intersect: compute intersection point.
            denom = (a1 * b2) - (a2 * b1);

            if (denom === 0)
                return 1; //collinear

            // lines_intersect
            return 1; //lines intersect, return true
        }

        function SameSign(a, b)
        {
            return (a < 0 && b < 0) || (a == 0 && b == 0) || (a > 0 && b > 0);
        }

        function UpdateBeltType (to)
        {
            updatingMetadata = true;

            j$("#Belt_Relationship__c").val(to);

            updatingMetadata = false;
        }

        function RotatePoint (p, center, degrees)
        {
            var rads = degrees * (Math.PI / 180);
            var cosT = Math.cos(rads);
            var sinT = Math.sin(rads);

            var x = cosT * (p.x - center.x) - sinT * (p.y - center.y) + center.x;
            var y = sinT * (p.x - center.x) + cosT * (p.y - center.y) + center.y;

            return new go.Point (x, y);
        }

        function SnapToKey (node, toKey)
        {
            var snapTo = toKey != null ? diagram.findNodeForKey(toKey) : null;

            SnapTo (node, snapTo);
        }

        function SnapTo (node, snapTo)
        {
            if (node.category == "resizableArrow" || node.category == "nonresizableArrow")
                MakeArrowShape (node, snapTo);

            if (snapTo != null)
            {
                if (node.data.snapping == "outside")
                {
                    var palType = node.data.objectType;
                    var accBool = false;
                    var newLoc = snapTo.location.copy();
                    if (palType == "Accessory")
                    {
                        accBool = true;
                    }
                    else
                    {
                        // GUIDE is the ROLL template
                        var toShape = snapTo.findObject("GUIDE");

                        var toDiam = toShape.measuredBounds.width - toShape.strokeWidth + 1;
                        var toRadius = toDiam / 2;                                    

                        newLoc.x += toRadius;
                    }

                    var shape = node.findObject("SHAPE");
                    var a = node.angle;
                    var config = GetConfig(node.data.recordType);
                    var offset;

                    if (node.data.objectType == "Doctor")
                    {
                        var docWidth = shape.measuredBounds.width * shape.scale;
                        
                        if (docWidth == 0)
                        {
                            // unwind then re-call ourselves to get the real value (wth gojs?)
                            setTimeout(function()
                            {
                                SnapTo (node, snapTo);
                            }, 1);

                            return;
                        }

                        newLoc.x += docWidth / 2;
                        
                        if (config == null)
                            offset = {x: 0, y:0};
                        else
                            offset = {x: config.Doctor_Offset_X__c, y: config.Doctor_Offset_Y__c};

                        if (shape.flip != null && (shape.flip == go.GraphObject.FlipVertical || shape.flip == go.GraphObject.Both))
                        {
                            offset.y *= -1;
                        }

                        newLoc.x += offset.x;
                        newLoc.y += offset.y;
                    }
                    else
                    if (accBool)
                    {
                        //var docWidth = shape.measuredBounds.width * shape.scale;
                        var docWidth = 50 * shape.scale;
                        newLoc.x += docWidth / 2;

                        if (config == null)
                            offset = {x: 0, y:0};
                        else
                            offset = {x: config.Doctor_Offset_X__c, y: config.Doctor_Offset_Y__c};

                        newLoc.x += offset.x;
                        newLoc.y += offset.y;
                    }
                    else // arrow
                    {
                        newLoc.x += {!OutsideArrowDistance};
                    }

                    newLoc = RotatePoint (newLoc, snapTo.location, a);

                    node.location = newLoc;
                }
                else
                if (node.data.snapping == "inside")
                {
                    node.location = snapTo.location;
                }
                else
                if (node.data.snapping == "under")
                {
                    var pShape = node.findObject("GUIDE");
                    var rShape = snapTo.findObject("GUIDE");

                    pShape.width  = rShape.measuredBounds.width;
                    pShape.height = rShape.measuredBounds.height;
                    node.position = snapTo.position.copy();
                    node.data.snappedTo = snapTo.data.key;
                    node.data.outside = !snapTo.data.outside;
                    node.movable = false
                    pShape.visible = false;

                    setTimeout(UpdateAllBelts, 1);
                }
            }
        }

        function SetupSnap(node)
        {
            if (node && node.data && node.data.snapping)
            {
                var snapTo = NearestNode (node, node.data.snapTo);
                if (snapTo != null)
                {
                    var snapKey = snapTo.data.key;

                    if (node.data.snappedTo != snapKey)
                        node.data.snapChange = true;

                    node.data.snappedTo = snapKey;

                    SnapTo(node, snapTo);

                    // on things like dropping a rotary joint from the palette
                    // directly onto a roll, gojs doesn't have the height until
                    // after we unwind (wth?) so defer the label a little
                    setTimeout (UpdateRollFindLabel, 5, snapTo);
                }
                else
                {
                    if (node.category == "resizableArrow" || node.category == "nonresizableArrow")
                        MakeArrowShape (node, snapTo);

                    var prev = node.data.snappedTo;

                    if (node.data.snappedTo != null)
                        node.data.snapChange = true;

                    node.data.snappedTo = null;

                    if (prev)
                        UpdateRollLabelFromKey(prev);
                }

                UnHighlight();
            }
        }

        function FixArrowShape (node)
        {
            if (node.category == "resizableArrow" || node.category == "nonresizableArrow")
            {
                var snapKey = node.data.snapTo;
                if (snapKey)
                {
                    var snapTo = diagram.findNodeForKey(snapKey);
                    MakeArrowShape (node, snapTo);
                }
            }
        }

        function MakeArrowShape(arrow, snapTo)
        {
            var shape = arrow.findObject("SHAPE");

            if (snapTo != null)
            {
                if (arrow.data.snapSize == null || arrow.data.snapSize == 0)
                {
                    // ugh..
                    if (arrow.data.snapHack == null)
                    {
                        arrow.data.snapHack = true;

                        setTimeout (function()
                        {
                            MakeArrowShape(arrow, snapTo);
                        }, 1);

                        return;
                    }
                }
            }

            if ((snapTo == null && arrow.data.snapSize != 0) ||
                (snapTo != null && arrow.data.snapSize == 0) ||
                (snapTo != null && arrow.data.snapSize != snapTo.measuredBounds.width) ||
                (shape.geometry.figures == null || shape.geometry.figures.length == 0))
            {
                var geo = new go.Geometry();
                var fig;

                var size;
                if (snapTo == null)
                {
                    size = ARROW_DEFAULT_SIZE;
                    arrow.data.snapSize = 0;
                }
                else
                {
                    //console.log("MakeArrowShape, snapTo: " + snapTo);
                    // ISSUE: Had to change the following line of code because wasn't drawing the Arrows correctly!!!
                    // SAM --> 19-OCT-2020
                    //size = snapTo.measuredBounds.width * snapTo.scale;
                    size = snapTo.findObject("GUIDE").actualBounds.width * snapTo.scale;
                    arrow.data.snapSize = size;
                }

                var arrowPoints = // points left to 9:00
                [
                    new go.Point (0, -(ARROW_HEAD_WIDTH / 2)),
                    new go.Point (-ARROW_HEAD_WIDTH, 0),
                    new go.Point (0, (ARROW_HEAD_WIDTH / 2)),
                    new go.Point (0, 0),
                ];

                if (arrow.data.snapping == "inside") //straight arrow
                {
                    if (snapTo == null)
                    {
                        if (arrow.data.arrowBegin)
                        {
                            fig = new go.PathFigure(0, 0, true);
                            RotateAndAdd (arrowPoints, 0, fig);
                            geo.add(fig);
                        }

                        fig = new go.PathFigure (0, 0, false);
                        fig.add(new go.PathSegment(go.PathSegment.Line, size, 0));
                        geo.add(fig);

                        if (arrow.data.arrowEnd)
                        {
                            fig = new go.PathFigure(size, 0, true);
                            RotateAndAdd (arrowPoints, 180, fig);
                            geo.add(fig);
                        }
                    }
                    else
                    {
                        var diameter = size - shape.strokeWidth;
                        var radius = diameter / 2;

                        var minLen = 25;
                        var maxLen = 60;

                        var endPoint = radius;
                        if (endPoint < minLen)
                            endPoint = minLen;
                        else
                        if (endPoint > maxLen)
                            endPoint = maxLen;

                        endPoint += radius;
                        endPoint -= ARROW_HEAD_WIDTH;

                        fig = new go.PathFigure(radius - 1, 0, false);
                        fig.add(new go.PathSegment(go.PathSegment.Line, endPoint, 0));
                        geo.add(fig);

                        fig = new go.PathFigure(endPoint, 0, true);
                        RotateAndAdd(arrowPoints, 180, fig);
                        geo.add(fig);

                        fig = new go.PathFigure(-radius, 0, false);
                        fig.add (new go.PathSegment(go.PathSegment.Line, -endPoint, 0));
                        geo.add(fig);

                        fig = new go.PathFigure(-endPoint, 0, true);
                        RotateAndAdd(arrowPoints, 0, fig);
                        geo.add(fig);

                        shape.scale = 1.0;
                    }
                }
                else // outside/arc
                {
                    if (snapTo != null)
                    {
                        var toShape = snapTo.findObject("GUIDE");

                        size = (toShape.measuredBounds.width + ({!OutsideArrowRadiusAdjust} * 2));
                    }

                    var deg = {!OutsideArrowDegrees};
                    var radius = size / 2;

                    arrow.scale = 1.0;

                    fig = new go.PathFigure(radius, 0, false);
                    fig.add(new go.PathSegment(go.PathSegment.Arc, 0, deg, 0, 0, radius, radius));
                    geo.add(fig);

                    var p;

                    p = LastPosition(fig);
                    fig = new go.PathFigure(p.x, p.y, true);
                    RotateAndAdd (arrowPoints, -(90 - deg), fig);
                    geo.add(fig);

                    fig = new go.PathFigure(radius, 0, false);
                    fig.add(new go.PathSegment(go.PathSegment.Arc, 0, -deg, 0, 0, radius, radius));
                    geo.add(fig);

                    p = LastPosition(fig);
                    fig = new go.PathFigure(p.x, p.y, true);
                    RotateAndAdd (arrowPoints, 90 - deg, fig);
                    geo.add(fig);
                }

                geo.normalize();
                shape.geometry = geo;
            }
        }

        function LastPosition(fig)
        {
            var offsetX = fig.startX;
            var offsetY = fig.startY;

            for (var it = fig.segments.iterator; it.next() ; )
            {
                var seg = it.value;

                if (seg.type == go.PathSegment.Arc)
                {
                    var offset = RotatePoint (new go.Point (offsetX, offsetY), new go.Point(seg.centerX, seg.centerY), seg.sweepAngle);

                    offsetX = offset.x;
                    offsetY = offset.y;
                }
                else
                {
                    offsetX = seg.endX;
                    offsetY = seg.endY;
                }
            }

            return new go.Point(offsetX, offsetY);
        }

        function RotateAndAdd(arrow, degrees, toFig)
        {
            var p = LastPosition(toFig);

            var offsetX = p.x;
            var offsetY = p.y;
            var center = new go.Point(0, 0);

            for (var i = 0; i < arrow.length; i++)
            {
                var rot = RotatePoint (arrow[i], center, degrees);

                toFig.add (new go.PathSegment(go.PathSegment.Line, rot.x + offsetX, rot.y + offsetY));
            }
        }

        function NearestNode (node, ofType)
        {
            var min = SnapDistanceForNode(node);
            var roll = null;

            if (min > 0)
            {
                var myBelt = null;
                var beltKeys = [];

                // if we snap to a belt (roll/placeholder), find the belt we're on and the other
                // nodes on the same belt and prevent silly things like resnapping to the same
                // belt (mostly for placeholder sanity)
                if (node.data.snapToBelt)
                {
                    for (var it = diagram.nodes.iterator; it.next() ; )
                    {
                        var belt = it.key;
                        if (belt.category == "belt")
                        {
                            var guides = belt.data.guides;
                            for (var i = 0; i < guides.length; i++)
                            {
                                if (guides[i].k == node.data.key)
                                {
                                    myBelt = belt;

                                    for (var j = 0; j < guides.length; j++)
                                        beltKeys.push (guides[j].k);

                                    break;
                                }
                            }
                        }
                    }
                }

                var nodeX = node.location.x;
                var nodeY = node.location.y;

                for (var it = diagram.nodes.iterator; it.next() ; )
                {
                    var other = it.value;
                    if (other.category == ofType)
                    {
                        var sameBelt = false;
                        for (var r = 0; r < beltKeys.length && !sameBelt; r++)
                        {
                            if (beltKeys[r] == other.data.key)
                                sameBelt = true;
                        }

                        if (!sameBelt)
                        {
                            var x = nodeX - other.location.x;
                            var y = nodeY - other.location.y;

                            var dist = Math.sqrt(x * x + y * y);

                            if (dist < min)
                            {
                                min = dist;
                                roll = other;
                            }
                        }
                        else
                        {
                            console.log ("NearestNode: skipping " + other.data.snappedTo + " - on same belt " + myBelt.data.key);
                        }
                    }
                }
            }

            return roll;
        }

        function FixViewport(d)
        {
            StillActive();

            if (printing)
                resetWatermarks = true;

            d.startTransaction("fix watermarks");

            var dscale = 1 / d.scale;
            var height = d.viewportBounds.height;
            var width = d.viewportBounds.width;

            var vw = width / dscale;
            var vh = height / dscale;

            var watermarks = d.findLayer("Watermarks");
            if (watermarks != null)
            {
                watermarks.parts.each (function(part)
                {
                    // It'd be nice (ie: more efficient) to only update the watermarks when needed
                    // but it's too weird to get right all the time. Browser issues, gojs issues,
                    // etc issues - better to have it work reliably

                    if (true)//resetWatermarks || (part._viewPosition && part._viewPosition.x == -1 && part._viewPosition.y == -1))
                    {
                        var pw = part.measuredBounds.width / dscale;
                        var ph = part.measuredBounds.height / dscale;

                        switch (part.name)
                        {
                            case "title":
                                part._viewPosition.x = (vw / 2) - (pw / 2);
                                part._viewPosition.y = 2;
                                break;

                            case "copyright":
                                part._viewPosition.x = 2;
                                part._viewPosition.y = (vh - ph - 2);
                                break;

                            case "kadantImage":
                                part._viewPosition.x = vw - (265 / 2);
                                part._viewPosition.y = vh - ( 46 / 2) - 2;
                                break;
                        }
                    }

                    part.visible = !printing || printIncludeWatermarks;
                    part.position = d.transformViewToDoc(part._viewPosition);
                    part.scale = dscale;
                });
            }

            resetWatermarks = false;

            d.commitTransaction("fix watermarks");
        }

        function HideShow(cb, selector, from)
        {
            var opened = j$(cb).is(':checked');
            if (opened)
                j$(selector).show(250, FixWidth);
            else
                j$(selector).hide(250, FixWidth);

            if (!loading)
            {
                var pref;
                switch (cb)
                {
                    case "#palette_cb":
                        pref = PREF_SHOW_PALETTE;
                        break;

                    case "#metadata_cb":
                        pref = PREF_SHOW_METADATA;
                        break;
                }

                if (pref)
                    UpdatePreference(pref, opened);
            }
        }

        function LoadPartSearch()
        {
            var partText = '';
            partText += '<div><a href="#searchClose" title="Close" class="searchClose">X</a><h2>Part Search</h2>';
            partText += '<div style="border:none;" width="100%" height="170px" />' +
                '<hr style="margin-right:0; width: 100%; border: 0.5px solid black;" />' +
                '<table><tr><td>Search</td><td><input id="partSearch" type="text" name="partSearch" /></td><td>' +
                '<span style="padding-left:5px"><input class="btn" id="partSearchBtnGo" name="partSearchBtnGo" onclick="FindParts();" value="Go" type="button" />' +    
                '</span></td></tr></table><br />' +                                    
                '<table><tr><td>Part Number</td><td><input id="kadantPart" type="text" name="kadantPart" readonly /></td>' +
                '<td><select name="partSelectNumber" id="partSelectNumber" onchange="SetDropDowns();">' + partFieldPartOptions + '</select></td></tr>' +
                '<tr><td>Description</td><td><input id="partDescription" type="text" name="partDescription" readonly /></td>' +
                '<td><select name="partSelectDescription" id="partSelectDescription">' + partFieldDescOptions + '</select></td></tr>' +
                '<tr><td>Customer Number</td><td><input id="customerItem" type="text" name="customerItem" readonly /></td>' + 
                '<td><select name="partSelectCustomerNum" id="partSelectCustomerNum">' + partFieldCustOptions + '</select></td></tr>' +
                '<tr><td></td><td align="right"><span style="padding-left:5px"><input class="btn" id="assignPart" name="assignPart" onclick="AssignPart();" value="Assign Part Info" type="button" />' +    
                '</span></td><td><span style="padding-left:5px"><input class="btn" id="resetPart" name="resetPart" onclick="ResetPartSearch();" value="Reset" type="button" /></span></td></tr></table></div>';
            partText += '</div>';
            return partText;
        }

        function FindParts()
        {
            // Fetch the part description and Customer Part Number using the Part Number entered from Opportunity Products
            var partString = document.getElementById("partSearch").value;
            document.getElementById("partSelectNumber").selectedIndex = 0;
            document.getElementById("partSelectDescription").selectedIndex = 0; 
            document.getElementById("partSelectCustomerNum").selectedIndex = 0;
            Visualforce.remoting.Manager.invokeAction
            (                                
                '{!$RemoteAction.MachineSectionMapController.PartSearch}', partString, '{!AccountId}',
                function(result, event)
                {
                    var ret = JSON.parse(result);
                    document.getElementById("kadantPart").value = ret.kadantPart;
                    document.getElementById("partDescription").value = ret.description;
                    document.getElementById("customerItem").value = ret.customerItem;
                },
                {escape: false}
            );                            
        }

        function AssignPart()
        {
            var num = document.getElementById("kadantPart").value;
            //console.log('Assign Part number = ' + num);
            var el = document.getElementById("partSelectNumber");
            var selNum = el.options[el.selectedIndex].value;
            if (el.selectedIndex > 0)
            {
                var selObj = document.getElementById(selNum);
                //console.log('selNum = ' + selNum);                            
                document.getElementById(selNum).value = num;
                UpdateMetadataValue(selObj);
            }

            var desc = document.getElementById("partDescription").value;
            //console.log('Assign Part desc = ' + desc);
            var em = document.getElementById("partSelectDescription");
            var selDesc = em.options[em.selectedIndex].value;
            if (em.selectedIndex > 0)
            {
                selObj = document.getElementById(selDesc);
                //console.log('selDesc = ' + selDesc);                            
                document.getElementById(selDesc).value = desc;
                UpdateMetadataValue(selObj);
            }

            var custNum = document.getElementById("customerItem").value;
            //console.log('Assign Customer Num = ' + custNum);
            var en = document.getElementById("partSelectCustomerNum");
            var selCust = en.options[en.selectedIndex].value;
            if (en.selectedIndex > 0)
            {
                selObj = document.getElementById(selCust);
                //console.log('selCust = ' + selCust);                            
                document.getElementById(selCust).value = custNum;
                UpdateMetadataValue(selObj);         
            }
        }
        
        function SetDropDowns()
        {
            var el = document.getElementById("partSelectNumber");
            var selNum = el.options[el.selectedIndex].value;
            if (el.selectedIndex > 0)
            {
                document.getElementById("partSelectDescription").selectedIndex = el.selectedIndex;
                document.getElementById("partSelectCustomerNum").selectedIndex = el.selectedIndex;
            }
        }

        function ResetPartSearch()
        {
            document.getElementById("partSearch").value = '';
            document.getElementById("kadantPart").value = '';
            document.getElementById("partSelectNumber").selectedIndex = 0;
            document.getElementById("partDescription").value = '';
            document.getElementById("partSelectDescription").selectedIndex = 0; 
            document.getElementById("customerItem").value = '';
            document.getElementById("partSelectCustomerNum").selectedIndex = 0;
        }

        function FixWidth()
        {
            var w = 100;

            if (j$("#palette").is(":visible"))
                w -= 15;

            if (j$("#metadataGroup").is(":visible"))
                w -= 35;

            //console.log ("change canvas width to " + w + '%');

            j$("#diagramDiv").width(w + "%");

            resetWatermarks = true;
            diagram.requestUpdate();
        }

        function AlignSelection(to)
        {
            diagram.startTransaction('align ' + to);

            var lastNode = null;
            for (var it = diagram.selection.iterator; it.next() ; )
            {
                lastNode = it.value;
            }

            if (lastNode)
            {
                for (var it = diagram.selection.iterator; it.next() ; )
                {
                    var node = it.value;

                    switch (to)
                    {
                        case "horizontal":
                            node.location = new go.Point (node.location.x, lastNode.location.y);
                            break;

                        case "vertical":
                            node.location = new go.Point (lastNode.location.x, node.location.y);
                            break;
                    }
                }
            }

            diagram.commitTransaction('align ' + to);
        }

        function Toast(message)
        {
            var didIt = false;

            try
            {
                var toast = $A.get("e.force:showToast");
                if (toast)
                {
                    toast.setParams(
                    {
                        "message": message
                    });

                    toast.fire();
                    didIt = true;
                }
            }
            catch (err)
            {
                // ignore and drop thru
            }


            if (!didIt)
            {
                var x = document.getElementById("toast");

                x.className = "show";
                x.innerHTML = message;

                setTimeout(function()
                {
                    x.className = x.className.replace("show", "");
                }, 2000);
            }
        }

        function NavigateToRetUrlForced()
        {
            NavigateToRetUrl(true);
        }

        function NavigateToRetUrl(force)
        {
            if (force)
            {
                diagramDirty = false;

                for (var it = diagram.nodes; it.next() ; )
                {
                    var node = it.value;
                    if (node.data.dirty)
                        node.data.dirty = false;
                }

                updateDirty();
            }

            NavigateTo("{!ReturnUrl}");
        }

        function NavigateToSection(sectionId)
        {
            var dirty = diagramDirty;

            for (var it = diagram.nodes; !dirty && it.next() ; )
            {
                var node = it.value;
                if (node instanceof go.Node && node.data.dirty)
                    dirty = true;
            }

            if (dirty)
            {
                var d = j$("#closeDialog").dialog();
            }
            else
            {
                var wth = ("" + Math.random()).substring(2);
                var url = "/apex/Machine_Section_Map?id=" + sectionId + "&wth=" + wth + "&retURL={!ReturnUrl}";
                NavigateTo(url);
            }
        }

        function NavigateTo(url)
        {
            if (!url || url == "")
                url = "/";

            //console.log ("navigate to " + url);

            try
            {
                if (sforce && sforce.one)
                {
                    sforce.one.navigateToURL (url, true);
                }
                else
                {
                    location.href = url;
                }
            }
            catch (err)
            {
                window.location = url;
            }
        }

        function PrintImages()
        {
            setTimeout (GenerateImages (960, 700, true), 1);
        }

        function GenerateImages(width, height, doPrint)
        {
            printing = true;
            printIncludeWatermarks = false;
            //console.log('Generate Images isBladeCabinetSection? ' + isBladeCabinetSection);

            // Use the following variables to reset the Diagram DIV 
            var orgWidth = j$("#diagramDiv").width();
            var orgHeight = j$("#diagramDiv").height();

            //console.log("Original Width: " + orgWidth + " Width passed in: " + width + " Original Length: " + orgHeight + " Length passed in: " + height);

            var imgDiv = document.getElementById('printImages');

            if (isBladeCabinetSection === "true")
            {
                var opts =
                {
                    showTemporary: true
                }

                if (!doPrint)
                {
                    opts.elementFinished = ProcessElement;
                }

                var img = diagram.makeSvg(opts);

                if (doPrint)
                {
                    img.classList.add("images");
                    imgDiv.appendChild(img);
                    imgDiv.appendChild(document.createElement("br"));

                    // especially on chrome, we need to unwind *then* call print or
                    // it won't have picked up the new images
                    setTimeout(window.print, 10);
                }
                else
                {
                    var content =
                        '<?xml version="1.0" encoding="UTF-8"?>\n' +
                        '<svg width="' + orgWidth + 'px" version="1.1" xmlns="http://www.w3.org/2000/svg" height="' + orgHeight + 'px" viewBox="0 0 ' + orgWidth  + ' ' + orgHeight + '" xmlns:xlink="http://www.w3.org/1999/xlink">\n' +
                        img.innerHTML.replace("", "&#169;") +
                        '\n</svg>\n';

                    var str = btoa(content);
                    UploadImage(str, '', 0);
                }
            }
            else
            {
                var prevScale = diagram.scale;
                var prevAlign = diagram.contentAlignment;                        
                
                imgDiv.innerHTML = '';

                // reset the div to the desired size
                j$("#diagramDiv").width(width);
                j$("#diagramDiv").height(height);
                diagram.scale = 1.0;

                // tell gojs we changed the size
                diagram.requestUpdate();

                // how big is the whole diagram?
                var bounds = diagram.documentBounds;
                var w = bounds.width;
                var h = bounds.height;

                var rescale;
                var rescaleW = width / w;
                var rescaleH = (height - 50) / h; // trim some for watermarks

                // smaller scale numbers mean zoomed "out" more..pick up the scale of
                // whichever dimension needs the most zooming out to fit on the page
                rescale = Math.min(rescaleW, rescaleH);

                //console.log("rescale " + w + " x " + h + " -> " + width + " x " + height + " = " + rescale);

                diagram.startTransaction("print rescale");

                diagram.scale = rescale;

                //console.log("scale " + diagram.minScale + " < " + diagram.scale + " < " + diagram.maxScale);

                diagram.contentAlignment = go.Spot.Center;

                printIncludeWatermarks = true;

                var opts =
                {
                    showTemporary: true
                }

                if (!doPrint)
                {
                    opts.elementFinished = ProcessElement;
                }

                var img = diagram.makeSvg(opts);

                if (doPrint)
                {
                    img.classList.add("images");
                    imgDiv.appendChild(img);
                    imgDiv.appendChild(document.createElement("br"));

                    // especially on chrome, we need to unwind *then* call print or
                    // it won't have picked up the new images
                    setTimeout(window.print, 10);
                }
                else
                {
                    var content =
                        '<?xml version="1.0" encoding="UTF-8"?>\n' +
                        '<svg width="960px" version="1.1" xmlns="http://www.w3.org/2000/svg" height="700px" viewBox="0 0 960 700" xmlns:xlink="http://www.w3.org/1999/xlink">\n' +
                        img.innerHTML.replace("", "&#169;") +
                        '\n</svg>\n';

                    var str = btoa(content);
                    UploadImage(str, '', 0);
                }

                // undo the stuff above..
                diagram.contentAlignment = prevAlign;
                FixWidth();
                diagram.scale = prevScale;
                FixViewport(diagram);                

                diagram.commitTransaction("print rescale");
                // Fix the width and height of the Diagram Div
                j$("#diagramDiv").width(orgWidth);
                j$("#diagramDiv").height(orgHeight);
            }    // Else isBladeCabinetSection, or in other words FALSE
            printing = false;
        }

        function UploadImage(svg, fileId, position) {
            var sectionId = '{!MachineSectionId}';
            var doneUploading = false;
            var svgSize = svg.length;
            var body = '';
            curPos = position + chunkSize;
            if (svgSize <= curPos) {
                body = svg.substring(position);
                doneUploading = true;
            }
            else {
                body = svg.substring(position, curPos);
            }
            MachineSectionMapController.SaveMap
            (
                sectionId, fileId, body, doneUploading,
                function (result, event) {
                    //console.log(result);
                    if (event.type === 'exception') {
                        console.log("exception");
                        console.log(event);
                    }
                    else if (event.status) {
                        var ret = JSON.parse(result);
                        if (doneUploading == true) {
                            console.log('Done uploading image!');
                        }
                        else {
                            fileId = ret.cv;
                            UploadImage(svg, fileId, curPos);
                        }
                    }
                        else
                        {
                            console.log(event.message);
                        }
                },
                {buffer: true, escape: false, timeout: 120000}
            );
        }

        function ProcessElement(g, svg)
        {
            if (g instanceof go.Picture)
            {
                var rtype = g.source;
                rtype = rtype.substring(rtype.lastIndexOf("/") + 1);
                var info = imageInfos[rtype];
                svg.setAttributeNS('http://www.w3.org/1999/xlink', 'href', 'data:' + info.mime + ';base64,' + info.data);
            }
        }

        function CopyBelts(oldToNew)
        {
            var copiedBelt = false;
            for (var key in oldToNew)
            {
                var orig = diagram.findNodeForKey(key);
                if (orig.data && orig.category == "belt")
                {
                    var newBeltKey = oldToNew[key];
                    var newBelt = diagram.findNodeForKey(newBeltKey);
                    copiedBelt = true;
                    var newGuides = [];

                    for (var i = 0; i < newBelt.data.guides.length; i++)
                    {
                        var g = newBelt.data.guides[i];

                        var newKey = oldToNew[g.k];
                        if (newKey)
                            newGuides.push ({k: newKey, to: null, from: null});
                    }
                    newBelt.data.guides = newGuides;
                }
            }

            if (copiedBelt)
                setTimeout (UpdateAllBelts, 1);
        }

        function CopyPartMetadata (oldToNew)
        {
            for (var oldId in oldToNew)
            {
                var oldVals = metadataVals[oldId];
                if (oldVals)
                {
                    // simple assign is by-ref in JS.. don't do that
                    var newVals = new Object();
                    for (var meta in oldVals)
                    {
                        newVals[meta] = oldVals[meta];
                    }
                    metadataVals[oldToNew[oldId]] = newVals;
                }
            }
            ResetMetadataPanel();
        }

        function FixHeight()
        {
            if (!printing)
            {
                // Set the height of the window to support a small amount of space at bottom of screen
                var windowHeight = window.innerHeight - 75;

                j$("#palette").height(windowHeight);
                j$("#metadataGroup").height(windowHeight);
                j$("#diagramDiv").height(windowHeight);

                resetWatermarks = true;
                //setTimeout(diagram.requestUpdate, 1);
                diagram.requestUpdate();
            }
        }

        function CopyMetadata()
        {
            for (var it = diagram.selection.iterator; it.next() ; )
            {
                var node = it.value;
                if (node.data)
                    copyMetadataKey = node.data.key;
            }
        }

        function PasteMetadata()
        {
            if (copyMetadataKey)
            {
                var src = metadataVals[copyMetadataKey];
                if (src)
                {
                    var count = 0;

                    var srcNode = diagram.findNodeForKey(copyMetadataKey);
                    if (srcNode && srcNode.data)
                    {
                        var objType = srcNode.data.sObjectType;
                        var recType = srcNode.data.recordType;
                        var config = GetConfig(srcNode.data.recordType);

                        for (var it = diagram.selection.iterator; it.next() ; )
                        {
                            var node = it.value;
                            if (node.data && node.data.sObjectType == objType && node.data.recordType == recType)
                            {
                                count++;

                                node.data.dirty = true;

                                FixLabel(node);

                                var dest = new Object();
                                for (var meta in src)
                                {
                                    // copy everything except the label field..
                                    if (meta != config.Label_Field__c)
                                        dest[meta] = src[meta];
                                }

                                metadataVals[node.data.key] = dest;
                            }
                        }

                        updateDirty();

                        ResetMetadataPanel();

                        if (count == 0)
                            Toast("No nodes of the same type are selected");
                        else
                            Toast("Metadata values copied to " + count + " node" + (count == 1 ? "" : "s"));
                    }
                }
            }
        }

        function sendToLightning(type, val)
        {
            if (lcHost)
            {
                var message = { "type": type, "value": val };

                //console.log("sendToLightning: " + type + " = " + val + " to " + lcHost);

                parent.postMessage(JSON.stringify(message), lcHost);
            }
        }

        function handleMessage(event)
        {
            if (event && event.origin == lcHost)
            {
                var j = JSON.parse(event.data);

                //console.log("VF handleMessage: " + j.type + " = " + j.value);

                switch (j.type)
                {
                    case "clearEdit":
                    {
                        if (!{!IsReadOnly})
                        {
                            ClearEditInfo("handleMessage", null);
                        }

                        break;
                    }
                }
            }
        }

        function getHost(whole, before)
        {
            var i = whole.indexOf(before, whole.indexOf("."));

            return i == -1 ? whole : whole.substring(0, i);
        }

        function updateDirty()
        {
            var isDirty = diagramDirty;

            for (var it = diagram.nodes; !isDirty && it.next() ; )
            {
                var node = it.value;
                if (node instanceof go.Node && node.data.dirty)
                    isDirty = true;
            }

            if (wasDirty != isDirty)
            {
                //console.log("dirty now = " + isDirty);

                sendToLightning("dirty", isDirty);
                wasDirty = isDirty;
            }
        }

        function assignCoverageValues(noz_code, noz_qty, noz_space, noz_ang, noz_height, showerID)
        {
            if ((noz_qty.length > 0) && (noz_space.length > 0) && (noz_ang.length > 0) && (noz_height.length > 0))
            {
                var nangle = getRotationAngle(noz_code);
                var sprayWidth = 2 * noz_height * Math.tan(noz_ang/2*Math.PI/180) * Math.cos(nangle*Math.PI/180);
                //console.log("Spray Width: " + sprayWidth);
                var totalSprayWidth = (noz_qty - 1) * noz_space + sprayWidth;
                totalSprayWidth = Math.round(totalSprayWidth, 0);
                //console.log("Total Spray Width: " + totalSprayWidth);

                // No Coverage calc: If distance > Spray Width then call helper function else 0
                var noCoverage = 0.0;
                if (noz_space > sprayWidth)
                {
                    noCoverage = getPercentCover(sprayWidth, noz_space, noz_qty, 0);
                }
                //console.log("No Cover: " + noCoverage);

                var singleCoverage = getPercentCover(sprayWidth, noz_space, noz_qty, 1);
                //console.log("Single Cover: " + singleCoverage);
                var doubleCoverage = getPercentCover(sprayWidth, noz_space, noz_qty, 2);       
                //console.log("Double Cover: " + doubleCoverage);
                var tripleCoverage = getPercentCover(sprayWidth, noz_space, noz_qty, 3);       
                //console.log("Triple Cover: " + tripleCoverage);
                var fourCoverage = getPercentCover(sprayWidth, noz_space, noz_qty, 4);       
                //console.log("Four Cover: " + fourCoverage);

                sforce.connection.sessionId = '{!$Api.Session_ID}';
                var theQuery = "Select Id, No_Coverage__c, Single_Coverage__c, Double_Coverage__c, Triple_Coverage__c, Four_Double_Coverage__c FROM Machine_Mapping_Cleaning__c WHERE Id = '" + showerID + "' limit 1";
                var result = sforce.connection.query(theQuery);
                var records = result.getArray('records');
                var myObject = records[0];

                var updateRecord = new Array();
                myObject.No_Coverage__c = noCoverage;
                myObject.Single_Coverage__c = singleCoverage;
                myObject.Double_Coverage__c = doubleCoverage;
                myObject.Triple_Coverage__c = tripleCoverage;
                myObject.Four_Double_Coverage__c = fourCoverage;

                updateRecord.push(myObject);
                result = sforce.connection.update(updateRecord); 

                if(result[0].getBoolean("success"))
                {                    
                    alert("Coverage values were saved successfully!");
                }
                else
                {
                    alert("There was an error while trying to save the Coverage values to the Server!");
                }
            }
            else
            {
                alert("Coverage values were not saved: missing data from the necessary fields!");
            }
        }

        function getPercentCover(nozSprayWidth, distance, num, n) {
            var coverage = 0.0;    
            var m = Math.floor(nozSprayWidth / distance, 0) + 1;

            if (n == m)
            {
                coverage = 100 * (num - (m - 1)) * (nozSprayWidth - distance * (m - 1)) / (distance * (num - 1) + nozSprayWidth);
            }
            else if (n == (m - 1))
            {
                if (m > 1)
                {
                    coverage = 100 * (2 * distance + (num - m) / (m - 1) * (nozSprayWidth - m * (nozSprayWidth - distance * (m - 1)))) / (distance * (num - 1) + nozSprayWidth); 
                }
                else
                {
                    coverage = 100 * (num - 1) * (distance - nozSprayWidth) / (distance * (num - 1) + nozSprayWidth);
                }
            }
            else if (n <= (m - 2))
            {
                coverage = 100 * 2 * distance / (distance * (num - 1) + nozSprayWidth);
            }
            else
            {
                coverage = 0;
            }
            return coverage;
        }

        function getRotationAngle(nozzle_code)
        {
            //console.log("Nozzle Code in: " + nozzle_code);
            var angle = 5;
            if (typeof nozzle_code != "undefined")
            {        
                if (nozzle_code != null)       
                {
                    var theCode = nozzle_code.substring(0,2);
                    if (["FF","FH","PN","PT","PP"].indexOf(theCode) > -1)
                    {
                        angle = 0;
                    }
                }
            }
            return angle;
        }
        
        function getDrawing(drawingField)
        {
            let name = document.getElementById(drawingField).value;
            let drawingId = '';
            //console.log('Inside getDrawing with name: ' + name);
            
            Visualforce.remoting.Manager.invokeAction
            (
                '{!$RemoteAction.MachineSectionMapController.GetDrawingId}', name, 
                function(result, event)
                {
                    var ret = JSON.parse(result);
                    //console.log('Return from Apex call: ' + JSON.stringify(ret));
                    drawingId = ret.drawing_id;
                    if (drawingId != '') {
                        //console.log('Drawing ID: ' + drawingId);
                        var theHost = window.location.hostname;
                        var url = "https://" + theHost + "/lightning/r/Drawing__c/" + drawingId + "/view";                        
                        var win = window.open(url, '_blank');
                        if (win) {
                            //Browser has allowed it to be opened
                            win.focus();
                        } else {
                            //Browser has blocked it
                            alert('Please allow popups for this website');
                        }
                    }
                    else {
                        // Show Toast that the Drawing hasn't been found
                        Toast("No Drawing exists for the Name entered: " + name);
                    }
                },
                {escape: false}
            );                   
        }
    </script>
</apex:page>